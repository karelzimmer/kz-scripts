#!/usr/bin/env bash
# shellcheck source=kz_common.sh
###############################################################################
# SPDX-FileComment: Install apps
#
# SPDX-FileCopyrightText: Karel Zimmer <info@karelzimmer.nl>
# SPDX-License-Identifier: CC0-1.0
###############################################################################


###############################################################################
# Imports
###############################################################################

source kz_common.sh


###############################################################################
# Constants
###############################################################################

readonly PROGRAM_NAME='kz-install'
PROGRAM_DESC=$(gettext 'Install apps')
readonly PROGRAM_DESC
readonly PROGRAM_LOGS="systemd-cat --identifier=$PROGRAM_NAME"

USAGE=$(gettext "Usage: kz install [-a|--apps] [-b|--browse] [-c|--cat]
                  [-f|--file <file>]... [-g|--gui] [-r|--remove]
                  [-h|--help] [-m|--manual] [-u|--usage] [-v|--version]
                  [--] [<app>...]")
readonly USAGE

HELP="$(gettext "Usage: kz install [<options>] [--] [<arguments>]")

$PROGRAM_DESC.

$(gettext 'Options:')
$(gettext "  Mandatory arguments to long options are mandatory for short \
options too.")

$(gettext '  -a, --apps     show list of apps')
$(gettext '  -b, --browse   browse installation files')
$(gettext '  -c, --cat      show contents of command file')
$(gettext "  -f, --file <file>
                 process specified installation file")
$(gettext '  -g, --gui      run in graphical mode,')
$(gettext '                 requires a desktop environment')
$(gettext '  -r, --remove   delete apps')
$(gettext '  -h, --help     show this help text')
$(gettext '  -m, --manual   show manual page')
$(gettext '  -u, --usage    show a short usage summary')
$(gettext '  -v, --version  show program version')

$(gettext 'Arguments:')
$(gettext '  <app>          process specified app')"
readonly HELP

readonly OPTIONS_SHORT='abcf:grhmuv'
readonly OPTIONS_LONG="apps,browse,cat,file:,gui,remove,help,manual,usage,\
version"


###############################################################################
# Globals
###############################################################################

declare OPTION_GUI=false
declare OPTION_REMOVE=false
declare REBOOT=true
declare -A FAILED_APPS=()


###############################################################################
# Functions
###############################################################################

# This function performs the script actions, such as checking the input.
function process() {
    local -A app_arguments=()
    local -a install_files=()
    local -i install_file_num=0
    local argument_app=false
    local command_file=''
    local err_flag=false
    local from='from'
    local install='install'
    local install_file_default_gpg=''
    local install_file_default=/usr/bin/$PROGRAM_NAME.sh
    local install_file=''
    local on='on'
    local option_apps=false
    local option_browse=false
    local option_cat=false
    local option_file=false
    local remove='remove'

    check_input "$@"

    if ! $option_file; then
        install_files[++install_file_num]=$install_file_default
        # Install commands in gpg file.
        install_file_default_gpg=\
$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX-decryptd.sh.gpg")
        gpg --import                        \
            /usr/share/kz/kz-public-key.gpg \
            2> >($PROGRAM_LOGS)
        gpg --decrypt                       \
            /usr/bin/kz-install.sh.gpg      \
            2> >($PROGRAM_LOGS)             > "$install_file_default_gpg"
        install_files[++install_file_num]=$install_file_default_gpg
    fi

    for install_file in "${install_files[@]}"; do
        if [[ ! -f $install_file ]]; then
            TEXT=$(eval_gettext "Installation file '\$install_file' not \
found.")
            errmsg "$TEXT"
            err_flag=true
        fi
    done
    if $err_flag; then
        exit $ERR
    fi

    if $option_browse; then
        process_option_browse
        exit $OK
    fi

    if $option_apps; then
        process_option_apps
        exit $OK
    fi

    command_file=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX-commands.sh")

    if $argument_app; then
        process_argument_app
    else
        process_setup_file_by_hostname
    fi

    if $option_cat; then
        process_option_cat
        exit $OK
    fi

    if [[ $UID -ne 0 ]]; then
        become_root
    fi
    installs
}


# This function checks the script input.
function check_input() {
    local parsed=''
    local program_name=${PROGRAM_NAME/kz-/kz }

    parsed=$(getopt --alternative                       \
                    --options       "$OPTIONS_SHORT"    \
                    --longoptions   "$OPTIONS_LONG"     \
                    --name          "$program_name"     \
                    --              "$@")               ||
                    {
                        infomsg "$USAGE"
                        exit $ERR
                    }
    eval set -- "$parsed"
    unset parsed

    process_options "$@"
}


# This function handles the script options and arguments.
function process_options() {
    local program_name=${PROGRAM_NAME/kz-/kz }

    while true; do
        case $1 in
            -a | --apps )
                option_apps=true
                shift
                ;;
            -b | --browse )
                option_browse=true
                shift
                ;;
            -c | --cat )
                option_cat=true
                shift
                ;;
            -f | --file )
                option_file=true
                install_files[++install_file_num]=$2
                shift 2
                ;;
            -g | --gui )
                if ! [[ ${DISPLAY-} ]]; then
                    TEXT="$program_name: $1: \
$(gettext 'no desktop environment available')
$USAGE"
                    infomsg "$TEXT"
                    exit $ERR
                fi
                OPTION_GUI=true
                shift
                ;;
            -r | --remove )
                OPTION_REMOVE=true
                install='remove'
                on='from'
                remove='install'
                from='on'
                shift
                ;;
            -h | --help )
                process_option_help
                exit $OK
                ;;
            -m | --manual )
                process_option_manual
                exit $OK
                ;;
            -u | --usage )
                process_option_usage
                exit $OK
                ;;
            -v | --version )
                process_option_version
                exit $OK
                ;;
            -- )
                shift
                break
                ;;
            * )
                TEXT="$PROGRAM_NAME: getopt: $(gettext 'internal error')"
                errmsg "$TEXT"
                exit $ERR
                ;;
        esac
    done

    if [[ $* ]]; then
        argument_app=true
        REBOOT=false
        while [[ $* ]]; do
            app_arguments[$1]=$1
            shift
        done
    fi
}


# This function browses through the installation file.
function process_option_browse() {
    less --no-init --quit-if-one-screen "${install_files[@]}"
}


# This function shows the available apps from the installation file.
function process_option_apps() {
    local apps=''

    TEXT="$(gettext 'The following apps are available:')

$(gettext 'NUM  APP')
"
    apps=$(
        grep    "#.*$install.*$on"      \
                "${install_files[@]}"   |
        tr      --squeeze-repeats       \
                '[:space:]'             |
        cut     --delimiter=' '         \
                --fields=3              |
        sort    --unique                |
        nl      --number-width=3        \
                --number-format=rn      \
                --number-separator='  ' \
                --body-numbering=a      || true
        )

    if [[ $apps ]]; then
        TEXT+="$apps

$(gettext 'Use "kz install <app>..." to install the apps.')
$(gettext "Use \"kz install --cat\" to view the contents of the installation \
file.")
$(gettext "Use \"kz install --cat <app>...\" to view the contents of the apps \
installation file.")
$(gettext "Use \"kz install --browse\" to view the contents of the default \
installation file.")"
    else
        TEXT+="$(gettext '  0  No apps found.')

$USAGE"
    fi
    infomsg "$TEXT"
}


# This function processes argument <app>.
function process_argument_app() {
    local app_argument=''

    for app_argument in "${app_arguments[@]}"; do
        process_install_file_by_app_argument
    done
}


# This function generates the command file from the installation file and
# filters by <app>.
function process_install_file_by_app_argument() {
    local app_match=false
    local input_record=''
    local no_app_match=true

    while read -r input_record; do
        case $input_record in
            '' )
                # Skip empty line.
                continue
                ;;
            '#'*$install*[[:space:]]"$app_argument"[[:space:]]*$on* )
                # Add matching app record to command file.
                app_match=true
                no_app_match=false
                printf '\n%s\n' "$input_record" >> "$command_file"
                ;;
            '#'*$install*$on* | '#'*$remove*$from* )
                # Skip mismatched app record.
                app_match=false
                ;;
            * )
                if $app_match; then
                    # Add record to command file.
                    printf '%s\n' "$input_record" >> "$command_file"
                fi
                ;;
        esac
    done < <(cat "${install_files[@]}")

    if $no_app_match; then
        TEXT=$(eval_gettext "App '\$app_argument' not found")
        errmsg "$TEXT"
    else
        # Add extra empty line  to command file.
        printf '\n' >> "$command_file"
    fi
}


# This function generates the command file from the installation file and
# filters by host.
function process_setup_file_by_hostname() {
    local host_match=false
    local input_record=''

    while read -r input_record; do
        case $input_record in
            '' )
                # Skip empty line.
                continue
                ;;
            '#'*$install*$on*'*' | '#'*$install*$on*$HOSTNAME* )
                # Add matching app record to command file.
                host_match=true
                printf '\n%s\n' "$input_record" >> "$command_file"
                ;;
            '#'*$install*$on* | '#'*$remove*$from* )
                # Skip mismatched app record.
                host_match=false
                ;;
            * )
                if $host_match; then
                    # Add record to command file.
                    printf '%s\n' "$input_record" >> "$command_file"
                fi
                ;;
        esac
    done < <(cat "${install_files[@]}")
    # Add extra empty line  to command file.
    printf '\n' >> "$command_file"
}


# This function displays the contents of the command file.
function process_option_cat() {
    less --no-init --quit-if-one-screen "$command_file"
}


# This function starts installing the apps.
function installs() {
    local -i app_tot_num=0
    local title=''

    app_tot_num=$(grep --count "#.*$install.*$on" "$command_file" || true)
    if [[ $app_tot_num -eq 0 ]]; then
        TEXT=$(gettext 'No commands to execute.' )
        infomsg "$TEXT"
        exit $OK
    fi

    title=$(gettext 'Install apps')
    TEXT=$(gettext 'Prepare installation')
    logmsg "$title"...

    if $OPTION_GUI; then
        # With '|& zenity --progress' global variables from called functions
        # are not passed, hence the process substitution with '> >(zenity...)'.
        process_command_file > >(
            zenity  --progress              \
                    --pulsate               \
                    --auto-close            \
                    --no-cancel             \
                    --width     700         \
                    --height    50          \
                    --title     "$title"    \
                    --text      "$TEXT"     2> /dev/null
            )
    else
        process_command_file
    fi
}


# This function reads commands from the command file for further processing.
function process_command_file() {
    local -i app_seq_num=0
    local -i cmd_seq_num=0
    local app_name_line=''
    local app_name=''
    local command_record=''

    if ! $OPTION_GUI; then
        TEXT="$(gettext 'NUM/TOT  APP')
         $(gettext 'COMMAND')..."
        infomsg "$TEXT"
    fi

    while read -r command_record; do
        case $command_record in
            '#'*$install* )
                # App record.
                app_name=$(
                    printf '%s\n' "$command_record"     |
                    tr --squeeze-repeats '[:space:]'    |
                    cut --delimiter=' ' --fields=3
                    )
                (( ++app_seq_num ))
                cmd_seq_num=0
                printf  -v app_name_line    \
                        "%3d/%-3d  %s"      \
                        "$app_seq_num"      \
                        "$app_tot_num"      \
                        "$app_name"
                ;;
            '' | '#'* )
                # Empty or comment line.
                continue
                ;;
            * )
                # Process command record.
                execute_command "$command_record"
                ;;
        esac
    done < "$command_file"
}


# This function reports and executes a command from the command file.
function execute_command() {
    local -i cmd_dis_len=0
    local -i cmd_dis_max=0
    local cmd_dis=''
    local cmd=${1:-unknown}

    (( ++cmd_seq_num ))

    check_package_manager

    if $OPTION_GUI; then
        if [[ $cmd_seq_num -eq 1 ]]; then
            logmsg "$app_name_line"
        fi
        printf '%s\n' "#$app_name_line\n\n$cmd"
    else
        if [[ $cmd_seq_num -eq 1 ]]; then
            logmsg  "$app_name_line"
            infomsg "$app_name_line"
        fi
        # Ellipsize terminal output.
        # Width 9 characters less, 9 for leading spaces.
        cmd_dis_max=$(( $(tput cols) - 9 ))
        if [[ ${#cmd} -gt $cmd_dis_max ]]; then
            # Width 12 characters less, 9 for leading spaces and 3 for trailing
            # ellipsis.
            cmd_dis_len=$(( $(tput cols) - 12 ))
            cmd_dis=${cmd:0:cmd_dis_len}...
        else
            cmd_dis=$cmd
        fi
        infomsg "         $cmd_dis"
    fi

    logmsg "$cmd"
    ERREXIT=false
    eval "$cmd" &> >($PROGRAM_LOGS) || FAILED_APPS[$app_name]=$app_name
    ERREXIT=true
}


# This function controls the termination of the script.
function term() {
    local operation=''

    if [[ ${FAILED_APPS[*]} ]]; then
        TEXT="$(gettext "The installation of the following apps contains \
errors:")
${FAILED_APPS[*]}

$(eval_gettext "Use \"journalctl --boot --id=\$PROGRAM_NAME\" in Terminal to \
view log messages.")

$(gettext "Try installing the apps again.")"
        errmsg "$TEXT"
        exit $ERR
    fi

    operation=$(gettext 'install')

    if $OPTION_REMOVE; then
        # shellcheck disable=SC2034
        operation=$(gettext 'remove')
    fi
    TEXT=$(eval_gettext "Apps \$operation completed.")

    if $REBOOT; then
        TEXT+="

$(gettext "The computer will now reboot to finish installing the apps and \
changing system settings.")"
    fi
    infomsg "$TEXT"

    if $REBOOT; then
        $OPTION_GUI || wait_for_enter
        sudo systemctl reboot
    fi

    exit $OK
}


###############################################################################
# Main
###############################################################################

function main() {
    init    "$@"
    process "$@"
    term
}

main "$@"
