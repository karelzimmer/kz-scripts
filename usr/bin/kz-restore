#!/usr/bin/env bash
# shellcheck source=kz_common.sh
###############################################################################
# SPDX-FileComment: Restore backup
#
# SPDX-FileCopyrightText: Karel Zimmer <info@karelzimmer.nl>
# SPDX-License-Identifier: CC0-1.0
###############################################################################


###############################################################################
# Imports
###############################################################################

source kz_common.sh


###############################################################################
# Variables
###############################################################################

declare KZ_PROGRAM_NAME='kz-restore'
declare KZ_PROGRAM_DESC
        KZ_PROGRAM_DESC=$(gettext 'Restore backup')
declare KZ_DISPLAY_NAME=${KZ_PROGRAM_NAME/kz-/kz }

declare KZ_USAGE
        KZ_USAGE="$(eval_gettext "Usage: \$KZ_DISPLAY_NAME [-g|--gui] \
[-s|--source DIRECTORY]
                  \$KZ_OPTIONS_USAGE")"

declare KZ_X_OPTIONS_HELP
        KZ_X_OPTIONS_HELP="$(gettext "  Mandatory arguments to long options \
are mandatory for short options too.")

$(gettext "  -g, --gui      run in graphical mode, requires desktop \
environment")
$(gettext '  -s, --source DIRECTORY
                 use backup in DIRECTORY')"

declare KZ_HELP
        KZ_HELP="$(eval_gettext "Usage: \$KZ_DISPLAY_NAME [OPTION...]")

$KZ_PROGRAM_DESC.

$(gettext 'Options:')
$KZ_X_OPTIONS_HELP
$KZ_OPTIONS_HELP"

declare KZ_X_OPTIONS_SHORT='gs:'
declare KZ_X_OPTIONS_LONG=',gui,source:'

declare KZ_MEDIUM=''
declare KZ_OPTION_SOURCE=false
declare KZ_SOURCE_ARGUMENT=''
declare KZ_SOURCE_MEDIUM=''
declare KZ_SOURCE=''
declare KZ_TARGET=$HOME


###############################################################################
# Functions
###############################################################################

# This function handles the script options and arguments.
function check_input() {
    local L_PARSED=''

    L_PARSED=$(
        getopt  --alternative                                               \
                --options       "${KZ_OPTIONS_SHORT}$KZ_X_OPTIONS_SHORT"    \
                --longoptions   "${KZ_OPTIONS_LONG}$KZ_X_OPTIONS_LONG"      \
                --name          "$KZ_DISPLAY_NAME"                          \
                --              "$@"
        )       || KZ_RC=$?
    if [[ $KZ_RC -ne $KZ_OK ]]; then
        infomsg "$KZ_USAGE"
        exit    $KZ_ERROR
    fi
    eval set -- "$L_PARSED"

    process_options   "$@"
    process_x_options "$@"
}


# This function handles the extra options and arguments.
function process_x_options() {
    while true; do
        case $1 in
            -g | --gui )
                if ! $KZ_DESKTOP_ENVIRONMENT; then
                    KZ_TEXT=\
"$KZ_DISPLAY_NAME: $1: $(gettext 'no desktop environment available')
$KZ_USAGE"
                    infomsg "$KZ_TEXT"
                    exit $KZ_ERROR
                fi
                KZ_OPTION_GUI=true
                shift
                ;;
            -s | --KZ_SOURCE )
                if $KZ_OPTION_SOURCE; then
                    KZ_TEXT="$KZ_DISPLAY_NAME: $1 $2: $(gettext "too many \
options")
$KZ_USAGE"
                    infomsg "$KZ_TEXT"
                    exit $KZ_ERROR
                fi
                KZ_OPTION_SOURCE=true
                KZ_SOURCE_ARGUMENT=$2
                shift 2
                ;;
            -- )
                shift
                break
                ;;
            * )
                shift
                ;;
        esac
    done

    if [[ -n $* ]]; then
        KZ_TEXT="$KZ_DISPLAY_NAME: $*: $(gettext 'arguments are not allowed')
$KZ_USAGE"
        infomsg "$KZ_TEXT"
        exit $KZ_ERROR
    fi
}


# This function processes the script options and arguments.
function process_input() {
    check_source
    restore_backup
    restore_settings
}


# This function checks if the source is available.
function check_source() {
    local L_USB_MOUNT_POINT="/media/$USER"

    if $KZ_RPM; then
        L_USB_MOUNT_POINT="/run/media/$USER"
    fi

    if $KZ_OPTION_SOURCE; then

        if [[ ! -d $KZ_SOURCE_ARGUMENT ]]; then
            KZ_TEXT="$KZ_DISPLAY_NAME: $KZ_SOURCE_ARGUMENT: \
$(gettext 'directory does not exist')
$KZ_USAGE"
            infomsg "$KZ_TEXT"
            exit $KZ_ERROR
        fi

        KZ_SOURCE=$KZ_SOURCE_ARGUMENT/$USER@$HOSTNAME
        KZ_SOURCE_MEDIUM=$KZ_SOURCE_ARGUMENT
    else
        KZ_MEDIUM=$(
            ls  --directory "$L_USB_MOUNT_POINT"/* 2> >($LOGCMD) || true
            )

        if [[ -z $KZ_MEDIUM ]]; then
            KZ_TEXT=$(gettext "No USB medium found.

Connect a USB medium.")
            infomsg "$KZ_TEXT"

            $KZ_OPTION_GUI || wait_for_enter

            KZ_MEDIUM=$(
                ls --directory "$L_USB_MOUNT_POINT"/* 2> >($LOGCMD) || true
                )

            if [[ -z $KZ_MEDIUM ]]; then
                errormsg "$KZ_TEXT"
                exit $KZ_ERROR
            fi
        fi

        KZ_MEDIUM=$(
            ls --directory "$L_USB_MOUNT_POINT"/* 2> >($LOGCMD) || true
            )

        if [[ $(printf '%s\n' "$KZ_MEDIUM" | wc --lines) -gt 1 ]]; then
            KZ_TEXT="$(eval_gettext "Connect only one USB medium.

Now connected:
\$KZ_MEDIUM

Disconnect media via Files.")"
            infomsg "$KZ_TEXT"

            $KZ_OPTION_GUI || wait_for_enter

            KZ_MEDIUM=$(
                ls --directory "$L_USB_MOUNT_POINT"/* 2> >($LOGCMD) || true
                )

            if [[ $(printf '%s\n' "$KZ_MEDIUM" | wc --lines) -gt 1 ]]; then
                errormsg "$KZ_TEXT"
                exit $KZ_ERROR
            fi
        fi

        KZ_SOURCE=$KZ_MEDIUM/kz-backup/$USER@$HOSTNAME
        KZ_SOURCE_MEDIUM=$KZ_MEDIUM

        if [[ ! -d $KZ_SOURCE ]]; then
            KZ_TEXT=$(eval_gettext "No backup found on connected USB medium.

Connect a USB medium with the directory \$USER@\$HOSTNAME.")
            errormsg "$KZ_TEXT"
            exit $KZ_ERROR
        fi
    fi
}


# This function restores the backup.
function restore_backup() {
    local       L_ERROR_FILE=''
    local       L_RSYNC_MESSAGES=''
    local   -i  L_RESTORE_RC=0

    L_ERROR_FILE=$(mktemp -t "$KZ_PROGRAM_NAME-errors-XXXXXXXXXX")

    KZ_TITLE=$(gettext 'Restore backup')
    KZ_TEXT=$(gettext 'Preparing restore (this can take a while)')

    if $KZ_OPTION_GUI; then
        logmsg "$KZ_TITLE"...
        rsync   --archive               \
                --acls                  \
                --xattrs                \
                --verbose               \
                "$KZ_SOURCE"/           \
                "$KZ_TARGET"/           \
                2> "$L_ERROR_FILE"      |
        sed     --expression='s/^/#/'   |
        zenity  --progress              \
                --auto-close            \
                --no-cancel             \
                --pulsate               \
                --width     600         \
                --height    50          \
                --title     "$KZ_TITLE" \
                --text      "$KZ_TEXT"  2> >($LOGCMD) || L_RESTORE_RC=$?
    else
        KZ_TEXT+='...'
        infomsg "$KZ_TEXT"
        rsync   --archive               \
                --acls                  \
                --xattrs                \
                --verbose               \
                --human-readable        \
                "$KZ_SOURCE"/           \
                "$KZ_TARGET"/           2> "$L_ERROR_FILE" || L_RESTORE_RC=$?
    fi

    if [[ $L_RESTORE_RC -ne $KZ_OK ]]; then
        # shellcheck disable=SC2034
        L_RSYNC_MESSAGES=$(cat "$L_ERROR_FILE")
        KZ_TEXT=$(eval_gettext "Restore ended with warnings or errors.

Some files may not be readable, or
were any files added or removed while restoring the backup, or
is there not enough space on \$KZ_TARGET.

Check the rsync messages (also in \$L_ERROR_FILE):
\$L_RSYNC_MESSAGES

Try restoring the back up again.
Use app 'Installation menu' and select '5 - Command menu', or
use app 'Restore backup', or
use app 'Terminal', type 'kz restore'.")
        errormsg "$KZ_TEXT"
        exit $KZ_ERROR
    fi

    rm --verbose "$L_ERROR_FILE" |& $LOGCMD
}


# This function restores the user settings.
function restore_settings() {
    local L_SETTINGS_DIR=$HOME/kz-backup

    if $KZ_DESKTOP_ENVIRONMENT; then
        logmsg 'Restore settings...'
        restore_setting_desktop
    fi
}


# This function restores the desktop background, if possible.
function restore_setting_desktop() {
    local L_INPUT_FILE="$L_SETTINGS_DIR/desktop"

    if [[ -f $L_INPUT_FILE ]]; then
        logmsg 'Restore the desktop background...'
        gsettings   set                                         \
                    org.gnome.desktop.background picture-uri    \
                    "file://$L_INPUT_FILE"
    fi
}


# This function controls the termination of the script.
function term_script() {
    local       L_NUM_NAME=''
    local       L_USERS=''
    local   -i  L_NUM_USERS

    L_NUM_USERS=$(find /home/* -prune -print | wc --lines)

    if [[ $L_NUM_USERS -eq 1 ]]; then
        KZ_TEXT=$(gettext 'The backup has been restored.')
    else
        L_USERS=$(
                gettext '_username_|userid|_user_'
                printf '\n'
                grep --regexp='/home' /etc/passwd   |
                cut  --delimiter=':' --fields=1,3,5 |
                tr ':' '|'
                )
        L_USERS+=$(
                printf '\n'
                while read -r L_NUM_NAME; do
                    printf '\n'
                    id "$L_NUM_NAME"
                done < <(
                    grep --regexp='/home' /etc/passwd |
                    cut  --delimiter=':' --fields=1
                    )
                )
        KZ_TEXT="$(eval_gettext "The backup has restored for \$USER (there \
are \$L_NUM_USERS users).")

$L_USERS"
    fi

    if [[ $KZ_SOURCE_MEDIUM == */media/* ]]; then
        term_script_usb || KZ_RC=$?

        if [[ $KZ_RC -eq $KZ_OK ]]; then
            KZ_TEXT+="

$(gettext 'The USB medium can be removed.')"
        else
            KZ_TEXT+="

$(gettext 'Disconnect the USB medium SAFELY YOURSELF!')"
        fi

    fi
    infomsg "$KZ_TEXT"

    exit $KZ_OK
}


# This function tries to unmount the USB device.
function term_script_usb() {
    local L_DEV=''
    local L_TEXT=''

    L_TEXT=$(gettext 'Disconnect the USB media')
    L_DEV='/dev/'$(
        lsblk   --ascii             |
        grep    --before-context=1  \
                "$KZ_SOURCE_MEDIUM"    |
        head    -1                  |
        cut     --delimiter='-'     \
                --fields=2          |
        cut     --delimiter=' '     \
                --fields=1
    )

    if $KZ_OPTION_GUI; then
        # With '|& zenity --progress' global variables from called functions
        # are not passed, hence the process substitution with '> >(zenity...)'.
        logmsg "$L_TEXT..."
        term_script_unmount > >(
            zenity  --progress              \
                    --pulsate               \
                    --auto-close            \
                    --no-cancel             \
                    --width     600         \
                    --height    50          \
                    --title     "$KZ_TITLE" \
                    --text      "$L_TEXT"   \
                    2> >($LOGCMD)
            )
    else
        infomsg "$L_TEXT..."
        term_script_unmount
    fi

    return $KZ_RC
}


# This function unmounts the USB device.
function term_script_unmount() {
    umount "$KZ_SOURCE_MEDIUM"                  |& $LOGCMD || KZ_RC+=$?
    udisksctl lock --block-device "$L_DEV"      |& $LOGCMD || KZ_RC+=$?
    udisksctl power-off --block-device "$L_DEV" |& $LOGCMD || KZ_RC+=$?
    sleep 1
}


###############################################################################
# Main
###############################################################################

function main() {
    init_script "$@"
    check_input "$@"
    process_input
    term_script
}

main "$@"
