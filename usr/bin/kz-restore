#!/usr/bin/env bash
# shellcheck source=kz_common.sh
###############################################################################
# Restore backup.
#
# This script restores a backup copy of the Home folder.
# Use 'man kz restore' for more information.
#
# Written by Karel Zimmer <info@karelzimmer.nl>, CC0 1.0 Universal
# <https://creativecommons.org/publicdomain/zero/1.0>, 2007-2023.
###############################################################################

###############################################################################
# Import
###############################################################################

PROGRAM_PATH=$(cd "$(dirname "$(realpath "$0")")" && pwd)
readonly PROGRAM_PATH
source "$PROGRAM_PATH"/kz_common.sh 2> >(systemd-cat --identifier=kz_common.sh)


###############################################################################
# Constants
###############################################################################

readonly PROGRAM_NAME='kz-restore'
PROGRAM_DESC=$(gettext 'Restore backup')
readonly PROGRAM_DESC
readonly DISPLAY_NAME=${PROGRAM_NAME/kz-/kz }

USAGE="$(eval_gettext "Usage: \$DISPLAY_NAME [-d|--dry-run] [-g|--gui] \
[-s|--source DIRECTORY]")
                  $OPTIONS_USAGE"
readonly USAGE
HELP="$(eval_gettext "Usage: \$DISPLAY_NAME [OPTION...]")

$PROGRAM_DESC.

$(gettext 'Options:')
  $(gettext "Mandatory arguments to long options are mandatory for short \
options too.")

  -d, --dry-run  $(gettext 'perform a test run without making any changes')
  -g, --gui      $(gettext 'starts in graphics mode')
$(gettext '  -s, --source DIRECTORY
                 use backup in DIRECTORY')
$OPTIONS_HELP"
readonly HELP
readonly X_OPTIONS_SHORT='dgs:'
readonly X_OPTIONS_LONG=',dry-run,gui,source:'


###############################################################################
# Variables
###############################################################################

declare dry_run_option=''
declare medium=''
declare option_dry_run=false
declare option_gui=false
declare option_source=false
declare source_argument=''
declare source_medium=''
declare source=''


###############################################################################
# Functions
###############################################################################

# This function handles the script options and arguments.
function check_input {
    local -i rc=0
    local parsed=''

    parsed=$(
        getopt  --alternative                                       \
                --options       "$OPTIONS_SHORT$X_OPTIONS_SHORT"    \
                --longoptions   "$OPTIONS_LONG$X_OPTIONS_LONG"      \
                --name          "$DISPLAY_NAME"                     \
                --              "$@"
        ) || rc=$?
    if [[ $rc -ne $OK ]]; then
        printf '%s\n' "$USAGE_LINE"
        exit $ERROR
    fi
    eval set -- "$parsed"

    process_common_options "$@"

    while true; do
        case $1 in
            --dry-run)
                option_dry_run=true
                dry_run_option='--dry-run'
                shift
                ;;
            -g|--gui)
                if [[ $EDITION = 'server' ]]; then
                    printf  "$DISPLAY_NAME: $1: %s\n$USAGE_LINE\n" \
                            "$(gettext 'not allowed on a server')"
                    exit $ERROR
                fi
                option_gui=true
                reset_terminal_attributes
                shift
                ;;
            -s|--source)
                if $option_source; then
                    printf  "$DISPLAY_NAME: $1 $2: %s\n$USAGE_LINE\n" \
                            "$(gettext 'too many options')"
                    exit $ERROR
                fi
                option_source=true
                source_argument=$2
                shift 2
                ;;
            --)
                shift
                break
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -n "$*" ]]; then
        printf  "$DISPLAY_NAME: $*: %s\n$USAGE_LINE\n" \
                "$(gettext 'arguments are not allowed')"
        exit $ERROR
    fi
}


# This function processes the script options and arguments.
function process_input {
    if $option_source; then
        if ! [[ -d $source_argument ]]; then
            printf  "$DISPLAY_NAME: $source_argument: %s\n$USAGE_LINE\n" \
                    "$(gettext 'directory does not exist')"
            exit $ERROR
        fi
        source=$source_argument/backup-$HOSTNAME-$USER
        source_medium=$source_argument
    else
        medium=$(ls --directory /media/"$USER"/* 2> >($logcmd) || true)
        if [[ -z $medium ]]; then
        text="$(eval_gettext "No USB medium found.

Connect a USB medium.")"
            msg_warning "$text"
            wait_for_enter
            medium=$(ls --directory /media/"$USER"/* 2> >($logcmd) || true)
            if [[ -z $medium ]]; then
                 msg_error "$text"
            exit $ERROR
            fi
        fi
        if [[ $(printf '%s\n' "$medium" | wc --lines) -gt 1 ]]; then
            text="$(eval_gettext "Connect only one USB medium.

Now connected:
\$medium

Disconnect media via Files.")"
            msg_warning "$text"
            wait_for_enter
            if [[ $(printf '%s\n' "$medium" | wc --lines) -gt 1 ]]; then
                msg_error "$text"
                exit $ERROR
            fi
        fi
        source=$medium/backup-$HOSTNAME-$USER
        source_medium=$medium
        if ! [[ -d $source ]]; then
            msg_error "$(eval_gettext "No backup found on connected USB medium.

Connect a USB medium with the directory backup-\$HOSTNAME-\$USER.")"
            exit $ERROR
        fi
    fi

    check_on_ac_power

    restore_backup
    
    if ! $option_dry_run; then
        if [[ $EDITION = 'desktop' ]]; then
            title=$(gettext 'Restore settings')
            text=$title
            if $option_gui; then
                restore_settings                |
                zenity  --progress              \
                        --pulsate               \
                        --auto-close            \
                        --no-cancel             \
                        --width     600         \
                        --height    50          \
                        --title     "$title"    \
                        --text      "$text"     2> >($logcmd)
            else
                msg_info "$text..."
                restore_settings
            fi
        fi
    fi
}


# This function restores the backup.
function restore_backup {
    local -i rc=0
    local target=$HOME

    title=$(gettext 'Restore backup')
    text=$(gettext 'Preparing restore (this can take a while)')
    if $option_gui; then
        rsync   --archive               \
                --verbose               \
                $dry_run_option         \
                "$source"/              \
                "$target"/              \
                2> >($logcmd)           |
        sed     --expression='s/^/#/'   |
        zenity  --progress              \
                --auto-close            \
                --no-cancel             \
                --pulsate               \
                --width     600         \
                --height    50          \
                --title     "$title"    \
                --text      "$text"     2> >($logcmd) || rc=$?
    else
        msg_info "$text..."
        rsync   --archive               \
                --verbose               \
                --human-readable        \
                $dry_run_option         \
                "$source"/              \
                "$target"/              2> >($logcmd) || rc=$?
    fi
    maxrc

    sync |& $logcmd || rc+=$?
    maxrc
}


# This function restores user settings.
function restore_settings {
    restore_settings_desktop_background
    restore_settings_favorite_apps
}


# This function restores the desktop background.
function restore_settings_desktop_background {
    local input_file
    input_file=$(xdg-user-dir PICTURES)/$(gettext 'Background')

    if [[ -f $input_file ]]; then
        gsettings   set                                         \
                    org.gnome.desktop.background picture-uri    \
                    "file://$input_file"
    fi
}


# This function restores the favorite apps.
function restore_settings_favorite_apps {
    local input_file
    input_file=$(xdg-user-dir DOCUMENTS)/$(gettext 'Favorites')

    if [[ -f $input_file ]]; then
        gsettings set org.gnome.shell favorite-apps "$(cat "$input_file")"
    fi
}


# This function controls the termination of the script.
function term_script {
    local dev=''
    local -i rc=0

    if $option_dry_run; then
        msg_error "$(gettext 'The backup was NOT restored (DRY RUN).')"
        exit $ERROR
    fi

    if [[ $maxrc -gt $OK ]]; then
        msg_error "$(eval_gettext "Restore ended with warnings or errors.

Some files may not be readable,
or were any files added or removed while restoring the backup,
or is there not enough space on \$target.
The maximum exit value is \$maxrc.
Check the log in the next screen.")"
        show_log
        exit $ERROR
    fi

    if [[ $source_medium == /media/* ]]; then
        term_script_unmount
    else
        msg_info "
${green}$(gettext 'The backup has been restored.')${normal}"
    fi
    exit $OK
}


# This function tries to unmount the USB device.
function term_script_unmount {
    local dev=''
    local -i rc=0

    text=$(gettext 'Disconnect the USB media')
    dev='/dev/'$(
        lsblk   --ascii             |
        grep    --before-context=1  \
                "$source_medium"    |
        head    -1                  |
        cut     --delimiter='-'     \
                --fields=2          |
        cut     --delimiter=' '     \
                --fields=1
    )
    if $option_gui; then
        umount "$source_medium"                     |& $logcmd || rc+=$?;   \
        udisksctl lock --block-device "$dev"        |& $logcmd || rc+=$?;   \
        udisksctl power-off --block-device "$dev"   |& $logcmd              |
        zenity  --progress                                                  \
                --pulsate                                                   \
                --auto-close                                                \
                --no-cancel                                                 \
                --width     600                                             \
                --height    50                                              \
                --title     "$title"                                        \
                --text      "$text"                                         \
                2> >($logcmd) || rc=$?
    else
        msg_info "$text..."
        umount "$source_medium"                     |& $logcmd || rc+=$?
        udisksctl lock --block-device "$dev"        |& $logcmd || rc+=$?
        udisksctl power-off --block-device "$dev"   |& $logcmd || rc+=$?
    fi
    if [[ $rc -eq $OK ]]; then
        msg_info "
${green}$(gettext 'The backup has been restored.')

$(gettext 'The USB medium can be removed.')${normal}"
    else
            msg_warning "
${green}$(gettext 'The backup has been restored.')${yellow}

$(gettext 'Disconnect the USB medium yourself (safely!).')"
    fi
}


###############################################################################
# Main Script
###############################################################################

function main {
    init_script "$@"
    check_input "$@"
    process_input
    term_script
}

main "$@"
