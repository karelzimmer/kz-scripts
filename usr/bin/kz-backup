#!/usr/bin/bash
# shellcheck source=kz_common.sh
###############################################################################
# Make backup.
#
# This script makes a backup copy of the Home folder.
# Use 'man kz backup' for more information.
#
# Written by Karel Zimmer <info@karelzimmer.nl>, CC0 1.0 Universal
# <https://creativecommons.org/publicdomain/zero/1.0>, 2007-2023.
###############################################################################

###############################################################################
# Import
###############################################################################

PROGRAM_PATH=$(cd "$(dirname "$(realpath "$0")")" && pwd)
readonly PROGRAM_PATH
source "$PROGRAM_PATH"/kz_common.sh 2> >(systemd-cat --identifier=kz_common.sh)


###############################################################################
# Constants
###############################################################################

readonly PROGRAM_NAME='kz-backup'
PROGRAM_DESC=$(gettext 'Make backup')
readonly PROGRAM_DESC
readonly DISPLAY_NAME=${PROGRAM_NAME/kz-/kz }

USAGE=$(eval_gettext "Usage: \$DISPLAY_NAME [-d|--dry-run] \
[-g|--gui] [-t|--target DIRECTORY]
                 \$OPTIONS_USAGE")
readonly USAGE
HELP="$(eval_gettext "Usage: \$DISPLAY_NAME [OPTION...]")

$PROGRAM_DESC.

$(gettext 'Options:')
  $(gettext "Mandatory arguments to long options are mandatory for short \
options too.")

  -d, --dry-run  $(gettext 'perform a test run without making any changes')
  -g, --gui      $(gettext 'starts in graphics mode')
$(gettext '  -t, --target DIRECTORY
                 put backup in DIRECTORY')
$OPTIONS_HELP"
readonly HELP
readonly X_OPTIONS_SHORT='dgt:'
readonly X_OPTIONS_LONG=',dry-run,gui,target:'


###############################################################################
# Variables
###############################################################################

declare dry_run_option=''
declare medium=''
declare option_dry_run=false
declare option_gui=false
declare option_target=false
declare target_argument=''
declare target_medium=''
declare target=''


###############################################################################
# Functions
###############################################################################

# This function handles the script options and arguments.
function check_input {
    local -i rc=0
    local parsed=''

    parsed=$(
        getopt  --alternative                                       \
                --options       "$OPTIONS_SHORT$X_OPTIONS_SHORT"    \
                --longoptions   "$OPTIONS_LONG$X_OPTIONS_LONG"      \
                --name          "$DISPLAY_NAME"                     \
                --              "$@"
        ) || rc=$?
    if [[ $rc -ne $OK ]]; then
        printf '%s\n' "$USAGE_LINE"
        exit $ERROR
    fi
    eval set -- "$parsed"

    process_common_options "$@"

    while true; do
        case $1 in
            -d|--dry-run)
                option_dry_run=true
                dry_run_option='--dry-run'
                shift
                ;;
            -g|--gui)
                if [[ $EDITION = 'server' ]]; then
                    printf  "$DISPLAY_NAME: $1: %s\n$USAGE_LINE\n" \
                            "$(gettext 'not allowed on a server')"
                    exit $ERROR
                fi
                option_gui=true
                reset_terminal_attributes
                shift
                ;;
            -t|--target)
                if $option_target; then
                    printf  "$DISPLAY_NAME: $1 $2: %s\n$USAGE_LINE\n" \
                            "$(gettext 'too many options')"
                    exit $ERROR
                fi
                option_target=true
                target_argument=$2
                shift 2
                ;;
            --)
                shift
                break
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -n "$*" ]]; then
        printf  "$DISPLAY_NAME: $*: %s\n$USAGE_LINE\n" \
                "$(gettext 'arguments are not allowed')"
        exit $ERROR
    fi
}


# This function processes the script options and arguments.
function process_input {
    if $option_target; then
        if ! [[ -d $target_argument ]]; then
            printf  "$DISPLAY_NAME: $target_argument: %s\n$USAGE_LINE\n" \
                    "$(gettext 'directory does not exist')"
            exit $ERROR
        fi
        target=$target_argument/backup-$HOSTNAME-$USER
        target_medium=$target_argument
    else
        medium=$(ls --directory /media/"$USER"/* 2> >($logcmd) || true)
        if [[ -z $medium ]]; then
            text="$(eval_gettext "No USB medium found.

Connect a USB medium.")"
            msg_warning "$text"
            wait_for_enter
            medium=$(ls --directory /media/"$USER"/* 2> >($logcmd) || true)
            if [[ -z $medium ]]; then
                msg_error "$text"
                exit $ERROR
            fi
        fi
        medium=$(ls --directory /media/"$USER"/* 2> >($logcmd) || true)
        if [[ $(printf '%s\n' "$medium" | wc --lines) -gt 1 ]]; then
            text="$(eval_gettext "Connect only one USB medium.

Now connected:
\$medium

Disconnect media via Files.")"
            msg_warning "$text"
            wait_for_enter
            medium=$(ls --directory /media/"$USER"/* 2> >($logcmd) || true)
            if [[ $(printf '%s\n' "$medium" | wc --lines) -gt 1 ]]; then
                msg_error "$text"
                exit $ERROR
            fi
        fi
        target=$medium/backup-$HOSTNAME-$USER
        target_medium=$medium
    fi

    check_on_ac_power

    if ! $option_dry_run; then
        if [[ $EDITION = 'desktop' ]]; then
            title=$(gettext 'Secure settings')
            text=$title
            if $option_gui; then
                backup_settings                 |
                zenity  --progress              \
                        --pulsate               \
                        --auto-close            \
                        --no-cancel             \
                        --width     600         \
                        --height    50          \
                        --title     "$title"    \
                        --text      "$text"     2> >($logcmd)
            else
                msg_info "$text..."
                backup_settings
            fi
        fi
    fi

    create_backup
}


# This function backs up user settings.
function backup_settings {
    migrate_settings_previously_backuped
    backup_settings_desktop_background
    backup_settings_favorite_apps
    backup_settings_installed_apps
    backup_settings_user_photo
}


# This function migrates backups of old user settings.
function migrate_settings_previously_backuped {
    move_file "$HOME"/kz-data/Achtergrond           "$HOME"/Afbeeldingen/
    move_file "$HOME"/kz-data/Apps                  "$HOME"/Documenten/
    move_file "$HOME"/kz-data/Favorieten            "$HOME"/Documenten/
    move_file "$HOME"/kz-data/Gebruikersfoto        "$HOME"/Afbeeldingen/

    move_file "$HOME"/Instellingen/Achtergrond      "$HOME"/Afbeeldingen/
    move_file "$HOME"/Instellingen/Apps             "$HOME"/Documenten/
    move_file "$HOME"/Instellingen/Favorieten       "$HOME"/Documenten/
    move_file "$HOME"/Instellingen/Gebruikersfoto   "$HOME"/Afbeeldingen/

    move_file "$HOME"/Settings/Apps                 "$HOME"/Documents/
    move_file "$HOME"/Settings/Background           "$HOME"/Pictures/
    move_file "$HOME"/Settings/Favorites            "$HOME"/Documents/
    move_file "$HOME"/Settings/Userphoto            "$HOME"/Pictures/

    rmdir   "$HOME"/kz-data         \
            "$HOME"/Instellingen    \
            "$HOME"/Settings        |& $logcmd || true
}


# This function moves a file from one location to another.
function move_file {
    mv "$1" "$2" 2> /dev/null || true
}


# This function copies the desktop background.
function backup_settings_desktop_background {
    local input_file=''
    local output_file=''

    if type xdg-user-dir &> /dev/null; then
        output_file=$(xdg-user-dir PICTURES)/$(gettext 'Background')
    else
        return $OK
    fi

    input_file=$(
        gsettings get org.gnome.desktop.background picture-uri  |
        sed --expression='s|%20| |g'                            |
        sed --expression="s/'//g"                               |
        sed --expression='s|file://||'                          || true
        )
    cp --preserve "$input_file" "$output_file" |& $logcmd || true
}


# This function saves the favorite apps.
function backup_settings_favorite_apps {
    local output_file=''

    if type xdg-user-dir &> /dev/null; then
        output_file=$(xdg-user-dir DOCUMENTS)/$(gettext 'Favorites')
    else
        return $OK
    fi

    gsettings   get                             \
                org.gnome.shell favorite-apps   \
                > "$output_file"                |& $logcmd || true
}


# This function creates a list of installed apps.
function backup_settings_installed_apps {
    local output_file=''
    local header1
    header1="$(gettext "[1/3] These packages are installed via Add or Remove \
Programs, with a command
      such as 'sudo apt --install <package|file>', or with kz install:")"
    local header2
    header2="$(gettext "[2/3] These snaps are installed via Add or Remove \
Programs,
      with '[sudo] install <snap>', or with kz install:")"
    local header3
    header3="$(gettext "[3/3] These repositories are added with the \
installation of a package, with
      the command 'sudo add-apt-repository ppa:<ppa-user>/<ppa-name>', or
      with kz install:")"
    local search=/etc/apt/sources.list

    if type xdg-user-dir &> /dev/null; then
        output_file=$(xdg-user-dir DOCUMENTS)/Apps
    else
        return $OK
    fi

    printf '%b\n' "$header1" > "$output_file"
    if ! apt list --manual-installed 2> >($logcmd) >> "$output_file"; then
        true
    fi

    printf '\n%b\n' "$header2" >> "$output_file"
    if ! snap list 2> >($logcmd) >> "$output_file"; then
        printf '%s\n' "$(gettext 'snap is not installed')" >> "$output_file"
    fi

    printf '\n%b\n' "$header3" >> "$output_file"
    cd  $search.d
    if !    grep    --recursive             \
                    --no-filename           \
                    --regexp='^deb '        \
                    --recursive             \
                    /etc/apt/sources.list   \
                    /etc/apt/sources.list.d |
            grep    --invert-match          \
                    --regexp='ubuntu.com'   |
            sort    --unique                >> "$output_file"; then
        true
    fi
}


# This function copies the user photo.
function backup_settings_user_photo {
    local input_file=/var/lib/AccountsService/icons/"$USER"
    local output_file=''

    if type xdg-user-dir &> /dev/null; then
        output_file=$(xdg-user-dir PICTURES)/$(gettext 'Userphoto')
    else
        return $OK
    fi

    cp --preserve "$input_file" "$output_file" |& $logcmd || true
}


# This function creates the backup.
function create_backup {
    local exclude=''
    local -i rc=0
    local -i backup_rc=0
    local source=$HOME

    exclude=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX")

    # Déjà Dup: Some locations are ignored by default.
    cat << EOF > "$exclude"
.adobe/Flash_Player/AssetCache
.cache
.ccache
.gvfs
.Private
.recent-applications.xbel
.recently-used.xbel
.steam/root
.thumbnails
.var/app/*/cache
.xsession-errors
snap/*/*/.cache
*CACHEDIR.TAG*
EOF

    # Skip git-controlled directories.
    cat << EOF >> "$exclude"
$(
    find    "$HOME"         \
            -maxdepth 2     \
            -name .git      \
            -type d         \
            -print          |
    cut     --delimiter='/' \
            --fields=4      |
    sort
    )
EOF

    title=$(gettext 'Make backup')
    text=$(gettext 'Preparing backup (this may take a while)')
    if $option_gui; then
        rsync   --archive                   \
                --verbose                   \
                $dry_run_option             \
                --delete                    \
                --exclude-from="$exclude"   \
                --delete-excluded           \
                "$source"/                  \
                "$target"/                  \
                2> >($logcmd)               |
        sed     --expression='s/^/#/'       |
        zenity  --progress                  \
                --auto-close                \
                --no-cancel                 \
                --pulsate                   \
                --width     600             \
                --height    50              \
                --title     "$title"        \
                --text      "$text"         2> >($logcmd) || backup_rc=$?
    else
        msg_info "$text..."
        rsync   --archive                   \
                --verbose                   \
                --human-readable            \
                $dry_run_option             \
                --delete                    \
                --exclude-from="$exclude"   \
                --delete-excluded           \
                "$source"/                  \
                "$target"/                  2> >($logcmd) || backup_rc=$?
    fi
    rm "$exclude"

    if [[ $backup_rc -eq 11 ]]; then
        msg_error "$(eval_gettext "No space left on device.

There is not enough space on \$target.")"
        exit $ERROR
    fi

    text=$(gettext "Writing data from memory (this may take a while)")
    if $option_gui; then
        sync                            |
        zenity  --progress              \
                --pulsate               \
                --auto-close            \
                --no-cancel             \
                --width     600         \
                --height    50          \
                --title     "$title"    \
                --text      "$text"     2> >($logcmd) || true
    else
        msg_info "
$text..."
        sync |& $logcmd || true
    fi
}


# This function controls the termination of the script.
function term_script {
    if $option_dry_run; then
        msg_error "$(gettext 'The backup has NOT been created (DRY RUN).')"
        exit $ERROR
    fi

    if [[ $target_medium == /media/* ]]; then
        term_script_unmount
    else
        msg_info "
${green}$(gettext 'The backup has been made.')${normal}"
    fi
    exit $OK
}


# This function tries to unmount the USB device.
function term_script_unmount {
    local dev=''
    local -i rc=0

    text=$(gettext 'Disconnect the USB media')
    dev='/dev/'$(
        lsblk   --ascii             |
        grep    --before-context=1  \
                "$target_medium"    |
        head    -1                  |
        cut     --delimiter='-'     \
                --fields=2          |
        cut     --delimiter=' '     \
                --fields=1
    )
    if $option_gui; then
        umount "$target_medium"                     |& $logcmd || rc+=$?;   \
        udisksctl lock --block-device "$dev"        |& $logcmd || rc+=$?;   \
        udisksctl power-off --block-device "$dev"   |& $logcmd              |
        zenity  --progress                                                  \
                --pulsate                                                   \
                --auto-close                                                \
                --no-cancel                                                 \
                --width     600                                             \
                --height    50                                              \
                --title     "$title"                                        \
                --text      "$text"                                         \
                2> >($logcmd) || rc+=$?
    else
        msg_info "$text..."
        umount "$target_medium"                     |& $logcmd || rc+=$?
        udisksctl lock --block-device "$dev"        |& $logcmd || rc+=$?
        udisksctl power-off --block-device "$dev"   |& $logcmd || rc+=$?
    fi
    if [[ $rc -eq $OK ]]; then
        msg_info "
${green}$(gettext 'The backup has been made.')

$(gettext 'The USB medium can be removed.')${normal}"
    else
            msg_warning "
${green}$(gettext 'The backup has been made.')${yellow}

$(gettext 'Disconnect the USB medium yourself (safely!).')"
    fi
}


###############################################################################
# Main Script
###############################################################################

function main {
    init_script "$@"
    check_input "$@"
    process_input
    term_script
}

main "$@"
