#!/usr/bin/bash
# shellcheck source=kz_common.sh disable=SC2155
###############################################################################
# Make backup.
#
# Written by Karel Zimmer <info@karelzimmer.nl>, CC0 1.0 Universal
# <https://creativecommons.org/publicdomain/zero/1.0>, 2007-2023.
###############################################################################


###############################################################################
# Import
###############################################################################

source "$(dirname "$0")"/kz_common.sh


###############################################################################
# Constants
###############################################################################

readonly    PROGRAM_NAME='kz-backup'
readonly    PROGRAM_DESC=$(gettext 'Make backup')
readonly    DISPLAY_NAME=${PROGRAM_NAME/kz-/kz }

readonly    USAGE="$(eval_gettext "Usage: \$DISPLAY_NAME [-d|--dry-run] [-g|--\
gui] [-t|--target DIRECTORY]
                 \$OPTIONS_USAGE")"
readonly    HELP="$(eval_gettext "Usage: \$DISPLAY_NAME [OPTION...]")

$PROGRAM_DESC.

$(gettext 'Options:')
$(gettext "  Mandatory arguments to long options are mandatory for short optio\
ns too.")

$(gettext '  -d, --dry-run  perform a test run without making any changes')
$(gettext '  -g, --gui      starts in graphics mode')
$(gettext '  -t, --target DIRECTORY
                 put backup in DIRECTORY')
$OPTIONS_HELP"

readonly    X_OPTIONS_SHORT='dgt:'
readonly    X_OPTIONS_LONG=',dry-run,gui,target:'


###############################################################################
# Variables
###############################################################################

declare     dry_run_option=''
declare     medium=''
declare     option_dry_run=false
declare     option_target=false
declare     target_argument=''
declare     target_medium=''
declare     target=''


###############################################################################
# Functions
###############################################################################

# This function handles the script options and arguments.
function check_input {
    local       parsed=''
    local   -i  parsed_rc=0

    parsed=$(
        getopt  --alternative                                       \
                --options       "$OPTIONS_SHORT$X_OPTIONS_SHORT"    \
                --longoptions   "$OPTIONS_LONG$X_OPTIONS_LONG"      \
                --name          "$DISPLAY_NAME"                     \
                --              "$@"
        ) || parsed_rc=$?
    if [[ $parsed_rc -ne $OK ]]; then
        printf '%s\n' "$USAGE_LINE"
        exit $ERROR
    fi
    eval set -- "$parsed"

    process_common_options "$@"

    while true; do
        case $1 in
            -d|--dry-run)
                option_dry_run=true
                dry_run_option='--dry-run'
                shift
                ;;
            -g|--gui)
                if [[ $EDITION = 'server' ]]; then
                    printf  "$DISPLAY_NAME: $1: %s\n$USAGE_LINE\n" \
                            "$(gettext 'not allowed on a server')"
                    exit $ERROR
                fi
                option_gui=true
                reset_terminal_attributes
                shift
                ;;
            -t|--target)
                if $option_target; then
                    printf  "$DISPLAY_NAME: $1 $2: %s\n$USAGE_LINE\n" \
                            "$(gettext 'too many options')"
                    exit $ERROR
                fi
                option_target=true
                target_argument=$2
                shift 2
                ;;
            --)
                shift
                break
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -n "$*" ]]; then
        printf  "$DISPLAY_NAME: $*: %s\n$USAGE_LINE\n" \
                "$(gettext 'arguments are not allowed')"
        exit $ERROR
    fi
}


# This function processes the script options and arguments.
function process_input {
    if $option_target; then
        if ! [[ -d $target_argument ]]; then
            printf  "$DISPLAY_NAME: $target_argument: %s\n$USAGE_LINE\n" \
                    "$(gettext 'directory does not exist')"
            exit $ERROR
        fi
        target=$target_argument/backup-$HOSTNAME-$USER
        target_medium=$target_argument
    else
        medium=$(ls --directory /media/"$USER"/* 2> >($logcmd) || true)
        if [[ -z $medium ]]; then
            text=$(gettext "No USB medium found.

Connect a USB medium.")
            msg_warning "$text"
            if ! $option_gui; then
                wait_for_enter
            fi
            medium=$(ls --directory /media/"$USER"/* 2> >($logcmd) || true)
            if [[ -z $medium ]]; then
                msg_error "$text"
                exit $ERROR
            fi
        fi
        medium=$(ls --directory /media/"$USER"/* 2> >($logcmd) || true)
        if [[ $(printf '%s\n' "$medium" | wc --lines) -gt 1 ]]; then
            text="$(eval_gettext "Connect only one USB medium.

Now connected:
\$medium

Disconnect media via Files.")"
            msg_warning "$text"
            if ! $option_gui; then
                wait_for_enter
            fi
            medium=$(ls --directory /media/"$USER"/* 2> >($logcmd) || true)
            if [[ $(printf '%s\n' "$medium" | wc --lines) -gt 1 ]]; then
                msg_error "$text"
                exit $ERROR
            fi
        fi
        target=$medium/backup-$HOSTNAME-$USER
        target_medium=$medium
    fi

    check_on_ac_power

    if ! $option_dry_run; then
        if [[ $EDITION = 'desktop' ]]; then
            title=$(gettext 'Secure settings')
            text=$title
            if $option_gui; then
                backup_settings                 |
                zenity  --progress              \
                        --pulsate               \
                        --auto-close            \
                        --no-cancel             \
                        --width     600         \
                        --height    50          \
                        --title     "$title"    \
                        --text      "$text"     2> >($logcmd)
            else
                printf '%s\n' "$text..."
                backup_settings
            fi
        fi
    fi

    create_backup
}


# This function backs up user settings.
function backup_settings {
    if $option_gui; then
        # To prevent screens from coming and going very quickly.
        sleep 2
    fi
    migrate_settings_previously_backuped
    backup_settings_desktop_background
    backup_settings_favorite_apps
    backup_settings_installed_apps
    backup_settings_user_photo
}


# This function migrates backups of old user settings.
function migrate_settings_previously_backuped {
    move_file "$HOME"/kz-data/Achtergrond           "$HOME"/Afbeeldingen/
    move_file "$HOME"/kz-data/Apps                  "$HOME"/Documenten/
    move_file "$HOME"/kz-data/Favorieten            "$HOME"/Documenten/
    move_file "$HOME"/kz-data/Gebruikersfoto        "$HOME"/Afbeeldingen/

    move_file "$HOME"/Instellingen/Achtergrond      "$HOME"/Afbeeldingen/
    move_file "$HOME"/Instellingen/Apps             "$HOME"/Documenten/
    move_file "$HOME"/Instellingen/Favorieten       "$HOME"/Documenten/
    move_file "$HOME"/Instellingen/Gebruikersfoto   "$HOME"/Afbeeldingen/

    move_file "$HOME"/Settings/Apps                 "$HOME"/Documents/
    move_file "$HOME"/Settings/Background           "$HOME"/Pictures/
    move_file "$HOME"/Settings/Favorites            "$HOME"/Documents/
    move_file "$HOME"/Settings/Userphoto            "$HOME"/Pictures/

    rmdir   "$HOME"/kz-data         \
            "$HOME"/Instellingen    \
            "$HOME"/Settings        |& $logcmd || true
}


# This function moves a file from one location to another.
function move_file {
    mv "$1" "$2" 2> /dev/null || true
}


# This function copies the desktop background.
function backup_settings_desktop_background {
    local   input_file=''
    local   output_file=''

    if type xdg-user-dir &> /dev/null; then
        output_file=$(xdg-user-dir PICTURES)/$(gettext 'Background')
    else
        return $OK
    fi

    input_file=$(
        gsettings get org.gnome.desktop.background picture-uri  |
        sed --expression='s|%20| |g'                            |
        sed --expression="s/'//g"                               |
        sed --expression='s|file://||'                          || true
        )
    cp --preserve "$input_file" "$output_file" |& $logcmd || true
}


# This function saves the favorite apps.
function backup_settings_favorite_apps {
    local   output_file=''

    if type xdg-user-dir &> /dev/null; then
        output_file=$(xdg-user-dir DOCUMENTS)/$(gettext 'Favorites')
    else
        return $OK
    fi

    gsettings   get                             \
                org.gnome.shell favorite-apps   \
                > "$output_file"                |& $logcmd || true
}


# This function creates a list of installed apps.
function backup_settings_installed_apps {
    local   output_file=''
    local   header1=$(gettext '==== START installed packages ====')
    local   footer1=$(gettext '==== END installed packages ====')
    local   header2=$(gettext '==== START installed snaps ====')
    local   footer2=$(gettext '==== END installed snaps ====')
    local   header3=$(gettext '==== START added repositories ====')
    local   footer3=$(gettext '==== END added repositories ====')
    local   search=/etc/apt/sources.list

    if type xdg-user-dir &> /dev/null; then
        output_file=$(xdg-user-dir DOCUMENTS)/Apps
    else
        return $OK
    fi

    printf '%s\n' "$header1" > "$output_file"
    apt list --manual-installed 2> >($logcmd) >> "$output_file" || true
    printf '%s\n' "$footer1" >> "$output_file"

    printf '\n%s\n' "$header2" >> "$output_file"
    if ! snap list 2> >($logcmd) >> "$output_file"; then
        printf '%s\n' "$(gettext 'snap is not installed')" >> "$output_file"
    fi
    printf '%s\n' "$footer2" >> "$output_file"

    printf '\n%s\n' "$header3" >> "$output_file"
    cd  $search.d
    grep    --recursive             \
            --no-filename           \
            --regexp='^deb '        \
            --recursive             \
            /etc/apt/sources.list   \
            /etc/apt/sources.list.d |
    grep    --invert-match          \
            --regexp='ubuntu.com'   |
    sort    --unique                >> "$output_file" || true
    printf '%s\n' "$footer3" >> "$output_file"
}


# This function copies the user photo.
function backup_settings_user_photo {
    local   input_file=/var/lib/AccountsService/icons/"$USER"
    local   output_file=''

    if type xdg-user-dir &> /dev/null; then
        output_file=$(xdg-user-dir PICTURES)/$(gettext 'Userphoto')
    else
        return $OK
    fi

    cp --preserve "$input_file" "$output_file" |& $logcmd || true
}


# This function creates the backup.
function create_backup {
    local   -i  backup_rc=0
    local       errors=''
    local       exclude=''
    local       rsync_messages=''
    local       source=$HOME

    exclude=$(mktemp -t "$PROGRAM_NAME-exclude-XXXXXXXXXX")
    errors=$(mktemp -t "$PROGRAM_NAME-errors-XXXXXXXXXX")

    # Déjà Dup: Some locations are ignored by default.
    cat << EOF > "$exclude"
.adobe/Flash_Player/AssetCache
.cache
.ccache
.gvfs
.Private
.recent-applications.xbel
.recently-used.xbel
.steam/root
.thumbnails
.var/app/*/cache
.xsession-errors
snap/*/*/.cache
*CACHEDIR.TAG*
EOF

    # Skip git-controlled directories.
    cat << EOF >> "$exclude"
$(
    find    "$HOME"         \
            -maxdepth 2     \
            -name .git      \
            -type d         \
            -print          |
    cut     --delimiter='/' \
            --fields=4      |
    sort
    )
EOF

    title=$(gettext 'Make backup')
    text=$(gettext 'Preparing backup (this may take a while)')
    if $option_gui; then
        rsync   --archive                   \
                --verbose                   \
                $dry_run_option             \
                --delete                    \
                --exclude-from="$exclude"   \
                --delete-excluded           \
                "$source"/                  \
                "$target"/                  \
                2> "$errors"                |
        sed     --expression='s/^/#/'       |
        zenity  --progress                  \
                --auto-close                \
                --no-cancel                 \
                --pulsate                   \
                --width     600             \
                --height    50              \
                --title     "$title"        \
                --text      "$text"         2> >($logcmd) || backup_rc=$?
    else
        printf '%s\n' "$text..."
        rsync   --archive                   \
                --verbose                   \
                --human-readable            \
                $dry_run_option             \
                --delete                    \
                --exclude-from="$exclude"   \
                --delete-excluded           \
                "$source"/                  \
                "$target"/                  2> "$errors" || backup_rc=$?
    fi
    rm "$exclude"

    if [[ $backup_rc -eq $OK ]]; then
        text=$(gettext "Writing data from memory (this may take a while)")
        if $option_gui; then
            sync                            |
            zenity  --progress              \
                    --pulsate               \
                    --auto-close            \
                    --no-cancel             \
                    --width     600         \
                    --height    50          \
                    --title     "$title"    \
                    --text      "$text"     &> >($logcmd)
        else
            printf '\n%s\n' "$text..."
            sync |& $logcmd
        fi
    else
        # shellcheck disable=SC2034
        rsync_messages=$(cat "$errors")
        msg_error "$(eval_gettext "Backup ended with warnings or errors.

Some files may not be readable,
or were any files added or removed while creating the backup,
or is there not enough space on \$target.

Check the rsync messages:
\$rsync_messages

Try creating the back up again.
Use app 'Installation menu' and select '5 - Command menu', or
use app Terminal, type 'kz backup'.")"
        exit $ERROR
    fi
}


# This function controls the termination of the script.
function term_script {
    if $option_dry_run; then
        printf  "${red}%b\n${normal}" \
                "$(gettext 'The backup has NOT been created (DRY RUN).')"
        exit $ERROR
    fi

    if [[ $target_medium == /media/* ]]; then
        term_script_unmount
    else
        msg_info "${green}
$(gettext 'The backup has been made.')${normal}"
    fi
    exit $OK
}


# This function tries to unmount the USB device.
function term_script_unmount {
    local       dev=''
    local   -i  rc=0

    text=$(gettext 'Disconnect the USB media')
    dev='/dev/'$(
        lsblk   --ascii             |
        grep    --before-context=1  \
                "$target_medium"    |
        head    -1                  |
        cut     --delimiter='-'     \
                --fields=2          |
        cut     --delimiter=' '     \
                --fields=1
    )
    if $option_gui; then
        umount "$target_medium"                     |& $logcmd || rc+=$?;   \
        udisksctl lock --block-device "$dev"        |& $logcmd || rc+=$?;   \
        udisksctl power-off --block-device "$dev"   |& $logcmd              |
        zenity  --progress                                                  \
                --pulsate                                                   \
                --auto-close                                                \
                --no-cancel                                                 \
                --width     600                                             \
                --height    50                                              \
                --title     "$title"                                        \
                --text      "$text"                                         \
                2> >($logcmd) || rc+=$?
    else
        printf '%s\n' "$text..."
        umount "$target_medium"                     |& $logcmd || rc+=$?
        udisksctl lock --block-device "$dev"        |& $logcmd || rc+=$?
        udisksctl power-off --block-device "$dev"   |& $logcmd || rc+=$?
    fi
    if [[ $rc -eq $OK ]]; then
        msg_info "${green}
$(gettext 'The backup has been made.')

$(gettext 'The USB medium can be removed.')${normal}"
    else
            msg_warning "${green}
$(gettext 'The backup has been made.')${yellow}

$(gettext 'Disconnect the USB medium yourself (safely!).')${normal}"
    fi
}


###############################################################################
# Main Script
###############################################################################

function main {
    init_script "$@"
    check_input "$@"
    process_input
    term_script
}

main "$@"
