#!/usr/bin/env bash
# shellcheck source=kz_common.sh
###############################################################################
# SPDX-FileComment: Mount network drive
#
# SPDX-FileCopyrightText: Karel Zimmer <info@karelzimmer.nl>
# SPDX-License-Identifier: CC0-1.0
###############################################################################


###############################################################################
# Imports
###############################################################################

source kz_common.sh


###############################################################################
# Variables
###############################################################################

declare PROGRAM_NAME='kz-nas'
declare PROGRAM_DESC
        PROGRAM_DESC=$(gettext 'Mount network drive')
declare DISPLAY_NAME=${PROGRAM_NAME/kz-/kz }

declare USAGE
        USAGE=$(eval_gettext "Usage: \$DISPLAY_NAME [-g|--gui] \
\$OPTIONS_USAGE")

declare X_OPTIONS_HELP
        X_OPTIONS_HELP=$(gettext "  -g, --gui      run in graphical mode, \
requires desktop environment")

declare HELP
        HELP="$(eval_gettext "Usage: \$DISPLAY_NAME [OPTION...]")

$PROGRAM_DESC.

$(gettext 'Options:')
$X_OPTIONS_HELP
$OPTIONS_HELP"

declare X_OPTIONS_SHORT='g'
declare X_OPTIONS_LONG=',gui'

declare NAS_LOGIN_DIR=/etc
declare NAS_LOGIN=$NAS_LOGIN_DIR/$PROGRAM_NAME.login
declare NAS_MOUNT_POINT=/mnt/${PROGRAM_NAME/kz-/kz/}
declare NAS_FIXED_IP_ADDRESS
        NAS_FIXED_IP_ADDRESS="$(gettext "Make sure the NAS has a fixed IP \
address.
This requires:

  - the MAC address of the NAS (looks like aa:bb:cc:dd:ee:ff)
  - access the NAS via a web browser
  - access the router via a web browser

  1. Select the MAC address of the NAS in the router
     IP address outside the range of DHCP automatically
     distributes the IP addresses (often 192.168.0.200).
  2. Select the fixed IP address in the NAS and turn off DHCP.")"

declare SYSTEMD_MOUNT_DIR=/etc/systemd/system
declare SYSTEMD_MOUNT_FILE=mnt-$PROGRAM_NAME.mount
declare SYSTEMD_MOUNT=$SYSTEMD_MOUNT_DIR/$SYSTEMD_MOUNT_FILE

declare NAS_USER_NAME
        NAS_USER_NAME=$(
    grep --regexp='1000' /etc/passwd | cut --delimiter=: --fields=1
    )
declare NAS_IP_ADDRESS=192.168.0.200
declare NAS_SHARE_NAME
        NAS_SHARE_NAME=$(
    grep --regexp='1000' /etc/passwd | cut --delimiter=: --fields=1
    )
declare NAS_PASSWORD='secret'


###############################################################################
# Functions
###############################################################################

# This function handles the script options and arguments.
function check_input {
    local       PARSED=''
    local   -i  PARSED_RC=0

    PARSED=$(
        getopt  --alternative                                       \
                --options       "${OPTIONS_SHORT}$X_OPTIONS_SHORT"  \
                --longoptions   "${OPTIONS_LONG}$X_OPTIONS_LONG"    \
                --name          "$DISPLAY_NAME"                     \
                --              "$@"
        ) || PARSED_RC=$?
    if [[ $PARSED_RC -ne $OK ]]
    then
        infomsg "$USAGE"
        exit $ERROR
    fi
    eval set -- "$PARSED"

    process_options   "$@"
    process_x_options "$@"
}


# This function handles the extra options and arguments.
function process_x_options {
    while true
    do
        case $1 in
            -g | --gui )
                if ! $DESKTOP_ENVIRONMENT
    then
                    TEXT=\
"$DISPLAY_NAME: $1: $(gettext 'no desktop environment available')
$USAGE"
                    infomsg "$TEXT"
                    exit $ERROR
                fi
                OPTION_GUI=true
                shift
                ;;
            -- )
                shift
                break
                ;;
            * )
                shift
                ;;
        esac
    done


    if [[ -n $* ]]
    then
        TEXT="$DISPLAY_NAME: $*: $(gettext 'arguments are not allowed')
$USAGE"
        infomsg "$TEXT"
        exit $ERROR
    fi

    become_root
    request_input
}


# This function asks the user for input.
request_input() {
    local PROMPT=''
    local QUEST1
    local QUEST2
    local QUEST3
    local QUEST4
    local QUEST5

    QUEST1=$(eval_gettext "Does the NAS have a fixed IP address such as \
\$NAS_IP_ADDRESS?")
    QUEST2=$(gettext 'IP address of the NAS')
    QUEST3=$(gettext 'User name on the NAS')
    QUEST4=$(gettext 'Password of this user on the NAS')
    QUEST5=$(gettext 'Share name of this user on the NAS')

    TITLE=$(gettext 'Question')
    if $OPTION_GUI
    then
        if ! zenity --question              \
                    --no-markup             \
                    --width     400         \
                    --height    100         \
                    --title     "$TITLE"    \
                    --text      "$QUEST1"   2> >($LOGCMD)
        then
            TITLE=$(gettext 'Notification')
            zenity  --info                              \
                    --no-markup                         \
                    --width     500                     \
                    --height    100                     \
                    --title     "$TITLE"                \
                    --text      "$NAS_FIXED_IP_ADDRESS" 2> >($LOGCMD) || true
            exit $OK
        fi
    else
        while true
    do
            PROMPT=$(eval_gettext "\$QUEST1 [y/N]: ")
            read -rp "$PROMPT"
            case $REPLY in
                [YyJj]* )
                    break
                    ;;
                [Nn]* | '' )
                    printf '%s\n' "$NAS_FIXED_IP_ADDRESS"
                    exit $OK
                    ;;
                * )
                    continue
                    ;;
            esac
        done
    fi

    TITLE=$(gettext 'Questions')
    TEXT=$(gettext 'Please answer the following questions')
    if $OPTION_GUI
    then
        REPLY=$(
            zenity  --forms                     \
                    --title         "$TITLE"    \
                    --text          "$TEXT"     \
                    --separator     ","         \
                    --add-entry     "$QUEST2"   \
                    --add-entry     "$QUEST3"   \
                    --add-password  "$QUEST4"   \
                    --add-entry     "$QUEST5"   2> >($LOGCMD)
	        ) || exit $OK
        NAS_IP_ADDRESS=$(   printf '%s' "$REPLY" | awk -F, '{print $1}')
        NAS_USER_NAME=$(    printf '%s' "$REPLY" | awk -F, '{print $2}')
        NAS_PASSWORD=$(     printf '%s' "$REPLY" | awk -F, '{print $3}')
        NAS_SHARE_NAME=$(   printf '%s' "$REPLY" | awk -F, '{print $4}')
    else
        TEXT="
$TEXT.
$(gettext "If you do not specify, the value in [] is used as the response.")"
        infomsg "$TEXT"
        read -rp "
$QUEST2? [$NAS_IP_ADDRESS]: "
        [[ -z $REPLY ]] || NAS_IP_ADDRESS=$REPLY
        read -rp "
$QUEST3? [$NAS_USER_NAME]: "
        [[ -z $REPLY ]] || NAS_USER_NAME=$REPLY
        read -rsp "
$QUEST4? [$NAS_PASSWORD]: "
        [[ -z $REPLY ]] || NAS_PASSWORD=$REPLY
        printf '\n'
        read -rp "
$QUEST5? [$NAS_SHARE_NAME]: "
        [[ -z $REPLY ]] || NAS_SHARE_NAME=$REPLY
    fi
}


# This function processes the script options and arguments.
process_input() {
    local TEXT0
    local TEXT1
    local TEXT2
    local TEXT3
    local TEXT4

    TEXT0=$(gettext 'Commands are being prepared')
    TEXT1=$(gettext 'Check dependencies')
    TEXT2=$(gettext 'Create NAS login')
    TEXT3=$(gettext 'Create systemd mount file')
    TEXT4=$(gettext 'Mount NAS')

    TITLE=$(gettext 'Mount network drive')
    if $OPTION_GUI
    then
        (
        printf '%s\n' "#$TEXT1"
        check_dependencies
        printf '%s\n' "#$TEXT2"
        create_nas_login
        printf '%s\n' "#$TEXT3"
        create_systemd_unit_file
        printf '%s\n' "#$TEXT4"
        mount_nas
        ) |&
        zenity  --progress              \
                --pulsate               \
                --auto-close            \
                --no-cancel             \
                --width     600         \
                --height    50          \
                --title     "$TITLE"    \
                --text      "$TEXT0"    2> >($LOGCMD)
    else
        printf '\n%s\n' "$TEXT1..."
        check_dependencies
        printf '\n%s\n' "$TEXT2..."
        create_nas_login
        printf '\n%s\n' "$TEXT3..."
        create_systemd_unit_file
        printf '\n%s\n' "$TEXT4..."
        mount_nas
    fi
}


# This function checks and installs dependencies.
function check_dependencies {
    logmsg 'Check_dependencies...'
    check_package_manager
    sudo apt-get install --yes cifs-utils samba |& $LOGCMD
}


# This function creates the secret needed to log in to the NAS.
create_nas_login() {
    logmsg 'Create NAS login...'
    TEXT="username=$NAS_USER_NAME\npassword=$NAS_PASSWORD"
    printf '%b\n' "$TEXT" > "$NAS_LOGIN"
    chmod --verbose '600' "$NAS_LOGIN" |& $LOGCMD
}


# This function creates the systemd unit mount file.
create_systemd_unit_file() {
    logmsg 'Create systemd unit file...'
    printf '%s\n' "[Unit]
Description=Mount NAS Directory

[Mount]
What=//$NAS_IP_ADDRESS/$NAS_SHARE_NAME
Where=$NAS_MOUNT_POINT
Type=cifs
Options=credentials=$NAS_LOGIN,vers=1.0,rw,noperm,iocharset=utf8,\
dir_mode=0777,file_mode=0777

[Install]
WantedBy=multi-user.target" > "$SYSTEMD_MOUNT"
}


# This function allows the NAS to be connected ad hoc.
mount_nas() {
    logmsg 'Mount NAS...'
    systemctl enable "$SYSTEMD_MOUNT_FILE"  |& $LOGCMD
    systemctl start "$SYSTEMD_MOUNT_FILE"   |& $LOGCMD || true
    systemctl daemon-reload                 |& $LOGCMD
}


# This function controls the termination of the script.
term_script() {
    systemctl status "$SYSTEMD_MOUNT_FILE" || true
    TEXT=$(eval_gettext "The systemd mount file is activated.
The NAS should be available at '\$NAS_MOUNT_POINT'.

Deactivate the systemd mount file and remove the NAS login with the following \
commands:")
    infomsg "$TEXT
[1] sudo systemctl disable $SYSTEMD_MOUNT_FILE
[2] sudo rm $NAS_LOGIN"
    exit $OK
}


###############################################################################
# Main
###############################################################################

function main {
    init_script "$@"
    check_input "$@"
    process_input
    term_script
}

main "$@"
