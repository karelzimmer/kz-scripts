#!/usr/bin/env bash
# shellcheck source=kz_common.sh
###############################################################################
# SPDX-FileComment: Set up apps
#
# SPDX-FileCopyrightText: Karel Zimmer <info@karelzimmer.nl>
# SPDX-License-Identifier: CC0-1.0
###############################################################################


###############################################################################
# Imports
###############################################################################

source kz_common.sh


###############################################################################
# Constants
###############################################################################

readonly PROGRAM_NAME='kz-setup'
PROGRAM_DESC=$(gettext 'Set up apps')
readonly PROGRAM_DESC
readonly PROGRAM_LOGS="systemd-cat --identifier=$PROGRAM_NAME"

USAGE=$(gettext "Usage: kz setup [-a|--apps] [-b|--browse] [-c|--cat]
                [-f|--file <file>] [-g|--gui] [-r|--reset]
                [-h|--help] [-m|--manual] [-u|--usage] [-v|--version]
                [<app>...]")
readonly USAGE

HELP="$(gettext "Usage: kz setup [<options>] [<app>...]")

$PROGRAM_DESC.

$(gettext 'Options:')
$(gettext "  Mandatory arguments to long options are mandatory for short \
options too.")

$(gettext '  -a, --apps     show list of apps')
$(gettext '  -b, --browse   browse setup file')
$(gettext '  -c, --cat      show contents of command file')
$(gettext "  -f, --file <file>
                 process specified setup file")
$(gettext '  -g, --gui      run in graphical mode,')
$(gettext '                 requires a desktop environment')
$(gettext '  -r, --reset    set apps on default values')
$(gettext '  -h, --help     show this help text')
$(gettext '  -m, --manual   show manual page')
$(gettext '  -u, --usage    show a short usage summary')
$(gettext '  -v, --version  show program version')

$(gettext 'Arguments:')
$(gettext '  <app>...       set up specified apps')"
readonly HELP

readonly OPTIONS_SHORT='abcf:grhmuv'
readonly OPTIONS_LONG="apps,browse,cat,file:,gui,reset,help,manual,usage,\
version"

readonly ON_HOST='on host'


###############################################################################
# Globals
###############################################################################

declare OPTION_GUI=false
declare OPTION_RESET=false
declare LOGOUT=true
declare -A FAILED_APPS=()



###############################################################################
# Functions
###############################################################################

# This function performs the script actions, such as checking the input.
function process() {
    local argument_app=false
    local command_file=''
    local file_argument=''
    local option_apps=false
    local option_browse=false
    local option_cat=false
    local option_file=false
    local reset_app='Reset app'
    local setup_app='Setup app'
    local setup_file_gpg=''
    local setup_file=/usr/bin/$PROGRAM_NAME.sh
    local -A app_arguments=()

    check_input "$@"

    setup_file_gpg=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX-decryptd.sh.gpg")

    if $option_file; then
        setup_file=$file_argument
        # Initialise the setup file gpg as "empty" with file header (GPG).
        cat << EOF > "$setup_file_gpg"
# shellcheck shell=bash
###############################################################################
# SPDX-FileComment: Setup file gpg for use with kz-setup script
#
# SPDX-FileCopyrightText: Karel Zimmer <info@karelzimmer.nl>
# SPDX-License-Identifier: CC0-1.0
###############################################################################
# Use "man kz setup.sh" to learn more about the format of this file.

# No commands to execute.
EOF
    else
        # Setup commands in GPG file.
        gpg --import                        \
            /usr/share/kz/kz-public-key.gpg \
            2> >($PROGRAM_LOGS)
        gpg --decrypt                       \
            /usr/bin/kz-setup.sh.gpg        \
            2> >($PROGRAM_LOGS)             > "$setup_file_gpg" || true
    fi

    if ! [[ -f $setup_file ]]; then
        TEXT=$(eval_gettext "No setup file found, looked for '\$setup_file'.")
        errmsg "$TEXT"
        exit $ERR
    fi

    if $option_browse; then
        process_option_browse
        exit $OK
    fi

    if $option_apps; then
        process_option_apps
        exit $OK
    fi

    command_file=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX-commands.sh")

    if $argument_app; then
        process_argument_app
    else
        process_setup_file_by_hostname
    fi

    if $option_cat; then
        process_option_cat
        exit $OK
    fi

    setup_apps
}


# This function checks the script input.
function check_input() {
    local parsed=''
    local program_name=${PROGRAM_NAME/kz-/kz }

    parsed=$(getopt --alternative                       \
                    --options       "$OPTIONS_SHORT"    \
                    --longoptions   "$OPTIONS_LONG"     \
                    --name          "$program_name"     \
                    --              "$@")               ||
                    {
                        infomsg "$USAGE"
                        exit $ERR
                    }
    eval set -- "$parsed"
    unset parsed

    process_options "$@"
}


# This function handles the script options and arguments.
function process_options() {
    local program_name=${PROGRAM_NAME/kz-/kz }

    while true; do
        case $1 in
            -a | --apps )
                option_apps=true
                shift
                ;;
            -b | --browse )
                option_browse=true
                shift
                ;;
            -c | --cat )
                option_cat=true
                shift
                ;;
            -f | --file )
                if $option_file; then
                    TEXT="$program_name: $1 $2: $(gettext 'too many options')
$USAGE"
                    infomsg "$TEXT"
                    exit $ERR
                fi
                option_file=true
                file_argument=$2
                shift 2
                ;;
            -g | --gui )
                if ! [[ ${DISPLAY-} ]]; then
                    TEXT="$program_name: $1: \
$(gettext 'no desktop environment available')
$USAGE"
                    infomsg "$TEXT"
                    exit $ERR
                fi
                OPTION_GUI=true
                shift
                ;;
            -r | --reset )
                OPTION_RESET=true
                setup_app='Reset app'
                reset_app='Setup app'
                shift
                ;;
            -h | --help )
                process_option_help
                exit $OK
                ;;
            -m | --manual )
                process_option_manual
                exit $OK
                ;;
            -u | --usage )
                process_option_usage
                exit $OK
                ;;
            -v | --version )
                process_option_version
                exit $OK
                ;;
            -- )
                shift
                break
                ;;
            * )
                TEXT="$PROGRAM_NAME: getopt: $(gettext 'internal error')"
                errmsg "$TEXT"
                exit $ERR
                ;;
        esac
    done

    if [[ $* ]]; then
        argument_app=true
        LOGOUT=false
        while [[ $* ]]; do
            app_arguments[$1]=$1
            shift
        done
    fi
}


# This function browses through the setup file.
function process_option_browse() {
    less --no-init --quit-if-one-screen "$setup_file" "$setup_file_gpg"
}


# This function shows the available apps from the setup file.
function process_option_apps() {
    local apps=''

    TEXT="$(gettext 'The following apps are available:')

$(gettext 'NUM  APP')
"
    apps=$(
        grep    "#.*$setup_app.*on"     \
                "$setup_file"           \
                "$setup_file_gpg"     |
        tr      --squeeze-repeats       \
                '[:space:]'             |
        cut     --delimiter=' '         \
                --fields=4              |
        sort    --unique                |
        nl      --number-width=3        \
                --number-format=rn      \
                --number-separator='  ' \
                --body-numbering=a      || true
        )

    if [[ $apps ]]; then
        TEXT+="$apps

$(gettext 'Use "kz setup <app>..." to set up the apps.')
$(gettext 'Use "kz setup --cat" to view the contents of the setup file.')
$(gettext "Use \"kz setup --cat <app>...\" to view the contents of the apps \
setup file.")
$(gettext "Use \"kz setup --browse\" to view the contents of the default \
setup file.")"
    else
        TEXT+="$(gettext '  0  No apps found.')

$USAGE"
    fi
    infomsg "$TEXT"
}


# This function processes argument <app>.
function process_argument_app() {
    local app_argument=''

    for app_argument in "${app_arguments[@]}"; do
        process_setup_file_by_app_argument
    done
}


# This function generates the command file from the setup file and filters by
# <app>.
function process_setup_file_by_app_argument() {
    local app_match=false
    local input_record=''
    local no_app_match=true

    while read -r input_record; do
        case $input_record in
            '' )
                # Skip empty line.
                continue
                ;;
            '#'*$setup_app*[[:space:]]"$app_argument"[[:space:]]*$ON_HOST* )
                # Add matching app record to command file.
                app_match=true
                no_app_match=false
                printf '\n%s\n' "$input_record" >> "$command_file"
                ;;
            '#'*$setup_app*$ON_HOST* | '#'*$reset_app*$ON_HOST* )
                # Skip mismatched app record.
                app_match=false
                ;;
            * )
                if $app_match; then
                    # Add record to command file.
                    printf '%s\n' "$input_record" >> "$command_file"
                fi
                ;;
        esac
    done < <(cat "$setup_file" "$setup_file_gpg")
    # Add extra empty line  to command file.
    printf '\n' >> "$command_file"

    if $no_app_match; then
        TEXT=$(eval_gettext "App '\$app_argument' not found")
        errmsg "$TEXT"
    fi
}


# This function generates the command file from the setup file and filters by
# host.
function process_setup_file_by_hostname() {
    local host_match=false
    local input_record=''

    while read -r input_record; do
        case $input_record in
            '' )
                # Skip empty line.
                continue
                ;;
            '#'*$setup_app*$ON_HOST*'*' | '#'*$setup_app*$ON_HOST*$HOSTNAME* )
                # Add matching app record to command file.
                host_match=true
                printf '\n%s\n' "$input_record" >> "$command_file"
                ;;
            '#'*$setup_app*$ON_HOST* | '#'*$reset_app*$ON_HOST* )
                # Skip mismatched app record.
                host_match=false
                ;;
            * )
                if $host_match; then
                    # Add record to command file.
                    printf '%s\n' "$input_record" >> "$command_file"
                fi
                ;;
        esac
    done < <(cat "$setup_file" "$setup_file_gpg")
    # Add extra empty line  to command file.
    printf '\n' >> "$command_file"
}


# This function displays the contents of the command file.
function process_option_cat() {
    less --no-init --quit-if-one-screen "$command_file"
}


# This function starts setting up the apps.
function setup_apps() {
    local title=''
    local -i app_tot_num=0

    app_tot_num=$(
        grep    --count                     \
                "#.*$setup_app.*$ON_HOST"   \
                "$command_file"             ||true
        )
    if [[ $app_tot_num -eq 0 ]]; then
        TEXT=$(gettext 'No commands to execute.' )
        infomsg "$TEXT"
        exit $OK
    fi

    title=$(gettext 'Set up apps')
    TEXT=$(gettext 'Preparing set up')
    logmsg "$title"...

    if $OPTION_GUI; then
        # With '|& zenity --progress' global variables from called functions
        # are not passed, hence the process substitution with '> >(zenity...)'.
        process_command_file > >(
            zenity  --progress              \
                    --pulsate               \
                    --auto-close            \
                    --no-cancel             \
                    --width     700         \
                    --height    50          \
                    --title     "$title"    \
                    --text      "$TEXT"     2> /dev/null
            )
    else
        process_command_file
    fi
}


# This function reads commands from the command file for further processing.
function process_command_file() {
    local app_name_line=''
    local app_name=''
    local command_record=''
    local -i app_seq_num=0
    local -i cmd_seq_num=0

    if ! $OPTION_GUI; then
        TEXT="$(gettext 'NUM/TOT  APP')
         $(gettext 'COMMAND')..."
        infomsg "$TEXT"
    fi

    while read -r command_record; do
        case $command_record in
            '#'*$setup_app* )
                # App record.
                app_name=$(
                    printf '%s\n' "$command_record"     |
                    tr --squeeze-repeats '[:space:]'    |
                    cut --delimiter=' ' --fields=4
                    )
                (( ++app_seq_num ))
                cmd_seq_num=0
                printf  -v app_name_line    \
                        "%3d/%-3d  %s"      \
                        "$app_seq_num"      \
                        "$app_tot_num"      \
                        "$app_name"
                ;;
            '' | '#'* )
                # Empty or comment line.
                continue
                ;;
            * )
                # Process command record.
                execute_command "$command_record"
                ;;
        esac
    done < "$command_file"
}


# This function reports and executes a command from the command file.
function execute_command() {
    local cmd=${1:-unknown}

    (( ++cmd_seq_num ))

    if $OPTION_GUI; then
        if [[ $cmd_seq_num -eq 1 ]]; then
            logmsg "$app_name_line"
        fi
        printf '%s\n' "#$app_name_line\n\n$cmd"
    else
        if [[ $cmd_seq_num -eq 1 ]]; then
            logmsg  "$app_name_line"
            infomsg "$app_name_line"
        fi
        infomsg "         $cmd"
    fi

    logmsg "$cmd"
    ERREXIT=false
    eval "$cmd" &> >($PROGRAM_LOGS) || FAILED_APPS[$app_name]=$app_name
    ERREXIT=true
}


# This function controls the termination of the script.
function term() {
    local operation=''

    if [[ ${FAILED_APPS[*]} ]]; then
        TEXT="$(gettext "The set up of the following apps contains errors:")
${FAILED_APPS[*]}

$(eval_gettext "Use \"journalctl --boot --id=\$PROGRAM_NAME\" in Terminal to \
view log messages.")

$(gettext "Try to set up the apps again.")"
        errmsg "$TEXT"
        exit $ERR
    fi

    operation=$(gettext 'set up')

    if $OPTION_RESET; then
        # shellcheck disable=SC2034
        operation=$(gettext 'reset')
    fi
    TEXT=$(eval_gettext "Apps \$operation completed.")

    if $LOGOUT; then

        if [[ ${DISPLAY-} ]]; then
            TEXT+="

$(gettext "You will now be logged out of the computer to finish setting up \
the apps and changing user settings.")"
        else
            TEXT+="

$(gettext "Type 'logout' to log out of the computer to finish setting up the \
apps and changing user settings.")"
        fi
        infomsg "$TEXT"

        if [[ ${DISPLAY-} ]]; then
            $OPTION_GUI || wait_for_enter

            if type gnome-session &> /dev/null; then
                gnome-session-quit --logout --no-prompt
            elif type ksmserver &> /dev/null; then
                qdbus org.kde.ksmserver /KSMServer logout 0 0 0
            elif type lxqt-session &> /dev/null; then
                lxqt-leave --logout
            elif type mate-session &> /dev/null; then
                mate-session-save --logout
            elif type xfce4-session &> /dev/null; then
                xfce4-session-logout --logout
            else
                TEXT='No logout command available.'
                logmsg "$TEXT"
                TEXT=$(gettext 'Log out of the computer yourself.')
                infomsg "$TEXT"
            fi
        fi
    else
        infomsg "$TEXT"
    fi

    exit $OK
}


###############################################################################
# Main
###############################################################################

function main() {
    init    "$@"
    process "$@"
    term
}

main "$@"
