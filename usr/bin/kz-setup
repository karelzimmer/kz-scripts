#!/usr/bin/env bash
# shellcheck source=kz_common.sh
# #############################################################################
# SPDX-FileComment: Set up apps
#
# SPDX-FileCopyrightText: Karel Zimmer <info@karelzimmer.nl>
# SPDX-License-Identifier: CC0-1.0
# #############################################################################


# #############################################################################
# Imports
# #############################################################################

source kz_common.sh as kz


# #############################################################################
# Constants
# #############################################################################

readonly PROGRAM_NAME='kz-setup'
PROGRAM_DESC=$(gettext 'Set up apps')
readonly PROGRAM_DESC
readonly PROGRAM_LOGS="systemd-cat --identifier=$PROGRAM_NAME"

USAGE=$(gettext "Usage: kz setup [-a|--apps] [-b|--browse] [-c|--cat]
                [-f|--file <file>]... [-g|--gui] [-r|--reset]
                [-h|--help] [-m|--manual] [-u|--usage] [-v|--version]
                [--] [<app>...]")
readonly USAGE

HELP="$(gettext "Usage: kz setup [<options>] [--] [<arguments>]")

$PROGRAM_DESC.

$(gettext 'Options:')
$(gettext "  Mandatory arguments to long options are mandatory for short \
options too.")

$(gettext '  -a, --apps     show list of apps')
$(gettext '  -b, --browse   browse setup files')
$(gettext '  -c, --cat      show contents of command file')
$(gettext "  -f, --file <file>
                 process specified setup files")
$(gettext '  -g, --gui      run in graphical mode,')
$(gettext '                 requires a desktop environment')
$(gettext '  -r, --reset    set apps on default values')
$(gettext '  -h, --help     show this help text')
$(gettext '  -m, --manual   show manual page')
$(gettext '  -u, --usage    show a short usage summary')
$(gettext '  -v, --version  show program version')

$(gettext 'Arguments:')
$(gettext '  <app>          process specified apps')"
readonly HELP

readonly OPTIONS_SHORT='abcf:grhmuv'
readonly OPTIONS_LONG="apps,browse,cat,file:,gui,reset,help,manual,usage,\
version"


# #############################################################################
# Globals
# #############################################################################

declare -A FAILED_APPS=()
declare ERROR_LOG=''
declare LOGOUT=false
declare OPTION_GUI=false
declare OPTION_RESET=false


# #############################################################################
# Functions
# #############################################################################

# This function performs the script actions, such as checking the input.
function process() {
    local -A app_arguments=()
    local -a setup_files=()
    local -i setup_file_num=0
    local argument_app=false
    local command_file=''
    local err_flag=false
    local option_apps=false
    local option_browse=false
    local option_cat=false
    local option_file=false
    local reset='RESET'
    local setup='SETUP'
    local setup_file_default_gpg=''
    local setup_file_default=/usr/bin/$PROGRAM_NAME.sh
    local setup_file=''
    local text=''

    check_input "$@"

    if ! $option_file; then
        setup_files[++setup_file_num]=$setup_file_default
        # Setup commands in gpg file.
        setup_file_default_gpg=\
$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX-decryptd.sh.gpg")
        gpg --import                        \
            /usr/share/kz/kz-public-key.gpg \
            2> >($PROGRAM_LOGS)
        gpg --decrypt                       \
            /usr/bin/kz-setup.sh.gpg        \
            2> >($PROGRAM_LOGS)             \
            > "$setup_file_default_gpg"
        setup_files[++setup_file_num]=$setup_file_default_gpg
    fi

    for setup_file in "${setup_files[@]}"; do
        if [[ ! -f $setup_file ]]; then
            text=$(eval_gettext "Setup file '\$setup_file' not found.")
            kz.errmsg "$text"
            err_flag=true
        fi
    done
    if $err_flag; then
        exit 1
    fi

    if $option_browse; then
        process_option_browse
        exit 0
    fi

    if $option_apps; then
        process_option_apps
        exit 0
    fi

    create_settings

    command_file=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX-commands.sh")

    if $argument_app; then
        process_argument_app
    else
        process_setup_file_by_hostname
    fi

    if $option_cat; then
        process_option_cat
        exit 0
    fi

    setup_apps
}


# This function checks the script input.
function check_input() {
    local parsed=''
    local program_name=${PROGRAM_NAME/kz-/kz }

    parsed=$(getopt --alternative                       \
                    --options       "$OPTIONS_SHORT"    \
                    --longoptions   "$OPTIONS_LONG"     \
                    --name          "$program_name"     \
                    --              "$@")               ||
                    {
                        kz.infomsg "$USAGE"
                        exit 1
                    }
    eval set -- "$parsed"
    unset parsed

    process_options "$@"
}


# This function handles the script options and arguments.
function process_options() {
    local program_name=${PROGRAM_NAME/kz-/kz }
    local text=''

    while true; do
        case $1 in
            -a | --apps )
                option_apps=true
                shift
                ;;
            -b | --browse )
                option_browse=true
                shift
                ;;
            -c | --cat )
                option_cat=true
                shift
                ;;
            -f | --file )
                option_file=true
                setup_files[++setup_file_num]=$2
                shift 2
                ;;
            -g | --gui )
                if [[ -z ${DISPLAY-} ]]; then
                    text="$program_name: $1: $(gettext "no desktop \
environment available")"
                    kz.infomsg "$text"
                    exit 1
                fi
                OPTION_GUI=true
                shift
                ;;
            -r | --reset )
                OPTION_RESET=true
                setup='RESET'
                reset='SETUP'
                shift
                ;;
            -h | --help )
                kz.process_option_help
                exit 0
                ;;
            -m | --manual )
                kz.process_option_manual
                exit 0
                ;;
            -u | --usage )
                kz.process_option_usage
                exit 0
                ;;
            -v | --version )
                kz.process_option_version
                exit 0
                ;;
            -- )
                shift
                break
                ;;
            * )
                text="$PROGRAM_NAME: getopt: $(gettext 'internal error')"
                kz.errmsg "$text"
                exit 1
                ;;
        esac
    done

    if [[ -n $* ]]; then
        argument_app=true
        while [[ -n $* ]]; do
            app_arguments[$1]=$1
            shift
        done
    else
        LOGOUT=true
    fi
}


# This function browses through the setup files.
function process_option_browse() {
    less --no-init --quit-if-one-screen < <(cat "${setup_files[@]}")
}


# This function shows the available apps from the setup files.
function process_option_apps() {
    local apps=''
    local text=''

    text="$(gettext 'The following apps are available:')

$(gettext 'NUM  APP')
"
    apps=$(
        grep    "#[[:space:]]\+${setup}[[:space:]]\+"   \
                "${setup_files[@]}"                     |
        tr      --squeeze-repeats                       \
                '[:space:]'                             |
        cut     --delimiter=' '                         \
                --fields=3                              |
        sort    --unique                                |
        nl      --number-width=3                        \
                --number-format=rn                      \
                --number-separator='  '                 \
                --body-numbering=a                      || true
        )

    if [[ -n $apps ]]; then
        text+="$apps

$(gettext 'Use "kz setup <app>..." to set up the apps.')
$(gettext 'Use "kz setup --cat" to view the contents of the setup file.')
$(gettext "Use \"kz setup --cat <app>...\" to view the contents of the apps \
setup file.")
$(gettext "Use \"kz setup --browse\" to view the contents of the default \
setup file.")"
    else
        text+="$(gettext '  0  No apps found.')

$USAGE"
    fi
    kz.infomsg "$text"
}

# This function creates a README and saves instructions for setting up xfce.
function create_settings() {
    local output_file=''
    local text=''
    local settings_dir=''

    kz.logmsg 'Setup settings...'

    settings_dir=$HOME/$(gettext 'Settings')
    if ! [[ -d $settings_dir ]]; then
        mkdir --verbose "$settings_dir" |& $PROGRAM_LOGS
    fi

    kz.logmsg 'Create settings README...'

    output_file=$settings_dir/$(gettext 'README')

    text="$(gettext "This folder contains files created by kz-backup and \
kz-setup.
These files are used by kz-restore and others.

Further reading:")
    man kz backup
    man kz restore
    man kz setup"
    printf '%s\n' "$text" > "$output_file"

    if type xfce4-session &> /dev/null; then
        output_file=$settings_dir/xfce.txt
        text="$(gettext "To setup the Xfce Panel and Whisker Menu:

1. Remove Panel 2.
2. Remove Applications Menu from Panel.
3. Add Whisker Menu to Panel.
4. Move Whisker Menu to far left.
5. Move Panel to bottom.
6. Position categories on left (Whisker Menu).
7. Position search entry on bottom (Whisker Menu).")"
        printf '%s\n' "$text" > "$output_file"
    fi
}

# This function processes argument <app>.
function process_argument_app() {
    local app_argument=''
    local err_flag=false

    for app_argument in "${app_arguments[@]}"; do
        process_setup_file_by_app_argument
    done

    if $err_flag; then
        exit 1
    fi
}


# This function generates the command file from the setup file and filters by
# <app>.
function process_setup_file_by_app_argument() {
    local app_match=false
    local setup_record=''
    local no_app_match=true
    local text=''

#   ChatGPT: *[[:space:]]*${variable1}[[:space:]]*${variable2}[[:space:]]*
#   Case → use [[:space:]]* and accept that it means “zero or more”.
    while read -r setup_record; do
        case $setup_record in
            '' )
                # Skip empty line.
                continue
                ;;
            '#'[[:space:]]*${setup}[[:space:]]*${app_argument}[[:space:]]* )
                # Add matching app record to command file.
                app_match=true
                no_app_match=false
                printf '\n%s\n' "$setup_record" >> "$command_file"
                ;;
            '#'[[:space:]]*${setup}[[:space:]]* | \
            '#'[[:space:]]*${reset}[[:space:]]* )
                # Skip mismatched app record.
                app_match=false
                ;;
            * )
                if $app_match; then
                    # Add record to command file.
                    printf '%s\n' "$setup_record" >> "$command_file"
                fi
                ;;
        esac
    done < <(cat "${setup_files[@]}")

    if $no_app_match; then
        err_flag=true
        text=$(eval_gettext "App '\$app_argument' not found.")
        kz.errmsg "$text"
    else
        # Add extra empty line  to command file.
        printf '\n' >> "$command_file"
    fi
}


# This function generates the command file from the setup file and filters by
# host.
function process_setup_file_by_hostname() {
    local host_match=false
    local setup_record=''

    while read -r setup_record; do
        case $setup_record in
            '' )
                # Skip empty line.
                continue
                ;;
            '#'[[:space:]]*${setup}[[:space:]]*'*' | \
            '#'[[:space:]]*${setup}[[:space:]]*$HOSTNAME* )
                # Add matching app record to command file.
                host_match=true
                printf '\n%s\n' "$setup_record" >> "$command_file"
                ;;
            '#'[[:space:]]*${setup}[[:space:]]* | \
            '#'[[:space:]]*${reset}[[:space:]]* )
                # Skip mismatched app record.
                host_match=false
                ;;
            * )
                if $host_match; then
                    # Add record to command file.
                    printf '%s\n' "$setup_record" >> "$command_file"
                fi
                ;;
        esac
    done < <(cat "${setup_files[@]}")
    # Add extra empty line  to command file.
    printf '\n' >> "$command_file"
}


# This function displays the contents of the command file.
function process_option_cat() {
    less --no-init --quit-if-one-screen "$command_file"
}


# This function starts setting up the apps.
function setup_apps() {
    local -i app_tot_num=0
    local text=''
    local title=''

    app_tot_num=$(
        grep    --count                                 \
                "#[[:space:]]\+${setup}[[:space:]]\+"   \
                "$command_file"                         || true
                )
    if [[ $app_tot_num -eq 0 ]]; then
        text=$(gettext 'No commands to execute.' )
        kz.infomsg "$text"
        exit 0
    fi

    ERROR_LOG=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX-error.log")
    text="** $ERROR_LOG (stderr)"
    printf '%s\n' "$text" > "$ERROR_LOG"

    title="$(gettext 'Set up apps') $(gettext 'progress')"
    text=$(gettext 'Preparing set up')
    kz.debugmsg "$title"...

    if $OPTION_GUI; then
        # With '|& zenity --progress' global variables from called functions
        # are not passed, hence the process substitution with '> >(zenity...)'.
        process_command_file > >(
            zenity  --progress              \
                    --pulsate               \
                    --auto-close            \
                    --no-cancel             \
                    --width     700         \
                    --height    50          \
                    --title     "$title"    \
                    --text      "$text"     2> /dev/null
            )
    else
        process_command_file
    fi
}


# This function reads commands from the command file for further processing.
function process_command_file() {
    local -i app_seq_num=0
    local -i cmd_seq_num=0
    local app_name_line=''
    local app_name=''
    local command_record=''
    local text=''

    if ! $OPTION_GUI; then
        text="$(gettext 'NUM/TOT  APP')
         $(gettext 'COMMAND')..."
        kz.infomsg "$text"
    fi

    while read -r command_record; do
        case $command_record in
            '#'[[:space:]]*${setup}[[:space:]]* )
                # App record.
                app_name=$(
                    printf '%s\n' "$command_record"     |
                    tr --squeeze-repeats '[:space:]'    |
                    cut --delimiter=' ' --fields=3
                    )
                (( ++app_seq_num ))
                cmd_seq_num=0
                printf  -v app_name_line    \
                        "%3d/%-3d  %s"      \
                        "$app_seq_num"      \
                        "$app_tot_num"      \
                        "$app_name"
                # To corrolate possible error messages with app name.
                printf ' \n%s\n' "-- App $app_name" >> "$ERROR_LOG"
                ;;
            '' | '#'* )
                # Empty or comment line.
                continue
                ;;
            * )
                # Process command record.
                execute_command "$command_record"
                ;;
        esac
    done < "$command_file"
}


# This function reports and executes a command from the command file.
function execute_command() {
    local -i cmd_dis_len=0
    local -i cmd_dis_max=0
    local cmd_dis=''
    local cmd=${1:-unknown}

    (( ++cmd_seq_num ))

    if $OPTION_GUI; then
        if [[ $cmd_seq_num -eq 1 ]]; then
            kz.debugmsg "$app_name_line"
        fi
        printf '%s\n' "#$app_name_line"
    else
        if [[ $cmd_seq_num -eq 1 ]]; then
            kz.infomsg "$app_name_line"
        fi
        # Ellipsize terminal output.
        # Width 9 characters less, 9 for leading spaces.
        cmd_dis_max=$(( $(tput cols) - 9 ))
        if [[ ${#cmd} -gt $cmd_dis_max ]]; then
            # Width 12 characters less, 9 for leading spaces and 3 for trailing
            # ellipsis.
            cmd_dis_len=$(( $(tput cols) - 12 ))
            cmd_dis=${cmd:0:cmd_dis_len}...
        else
            cmd_dis=$cmd
        fi
        kz.infomsg "         $cmd_dis"
    fi

    kz.debugmsg "$cmd"
    eval    "$cmd"              \
            1> >($PROGRAM_LOGS) \
            2>> "$ERROR_LOG"    || FAILED_APPS[$app_name]=$app_name
}


# This function controls the termination of the script.
function term() {
    local operation=''
    local program_name=${PROGRAM_NAME/kz-/kz }
    local text=''
    local title=''

    # Error-log (stderr) also to the main log.
    kz.logmsg '---------------------------------------------------------------'
    printf '%s' "$(<"$ERROR_LOG")" |& $PROGRAM_LOGS
    kz.logmsg '---------------------------------------------------------------'

    if [[ -n ${FAILED_APPS[*]} ]]; then
        title="$PROGRAM_DESC $(gettext 'error messages')"
        text="$(gettext "The set up of the following apps contains errors:")
${FAILED_APPS[*]}

$(gettext 'Actions to take:')
$(gettext 'Check the error messages after this.')
$(gettext 'Try to set up the apps again.')"
        kz.errmsg "$text"

        if $OPTION_GUI; then
            zenity  --text-info             \
                    --filename="$ERROR_LOG" \
                    --width     700         \
                    --height    500         \
                    --title     "$title"    2> /dev/null || true
        else
            kz.wait_for_enter
            kz.infomsg "$title $ERROR_LOG:"
            less --no-init --quit-if-one-screen "$ERROR_LOG"
        fi
    fi

    operation=$(gettext 'set up')

    if $OPTION_RESET; then
        # shellcheck disable=SC2034
        operation=$(gettext 'reset')
    fi
    text=$(eval_gettext "Apps \$operation completed.")

    if $LOGOUT; then

        if [[ -n ${DISPLAY-} ]]; then
            text+="

$(gettext "You will now be logged out of the computer to finish setting up \
the apps and changing user settings.")"
        else
            text+="

$(gettext "Type 'logout' to log out of the computer to finish setting up the \
apps and changing user settings.")"
        fi
        kz.infomsg "$text"

        if [[ -n ${DISPLAY-} ]]; then
            # A GUI is available
            $OPTION_GUI || kz.wait_for_enter

            if type cinnamon-session &> /dev/null; then
                # Cinnamon.
                cinnamon-session-quit --logout --force
            elif type gnome-session &> /dev/null; then
                # GNOME.
                gnome-session-quit --logout --no-prompt
            elif type ksmserver &> /dev/null; then
                # KDE.
                if type qdbus &> /dev/null; then
                    qdbus org.kde.ksmserver /KSMServer logout 0 0 0
                elif type qdbus6 &> /dev/null; then
                    qdbus6 org.kde.Shutdown /Shutdown org.kde.Shutdown.logout
                fi
            elif type lxsession &> /dev/null; then
                # LXDE.
                lxde-logout
            elif type lxqt-session &> /dev/null; then
                # LXQt.
                lxqt-leave --logout
            elif type mate-session &> /dev/null; then
                # MATE.
                mate-session-save --logout
            elif type xfce4-session &> /dev/null; then
                # Xfce.
                xfce4-session-logout --logout
            else
                text='No logout command available.'
                kz.debugmsg "$text"
                text=$(gettext 'Log out of the computer yourself.')
                kz.infomsg "$text"
            fi
        fi
    else
        kz.infomsg "$text"
    fi
    exit 0
}


# #############################################################################
# Main
# #############################################################################

function main() {
    kz.init "$@"
    process "$@"
    term
}

main "$@"
