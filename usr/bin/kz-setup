#!/usr/bin/env bash
# shellcheck source=kz_common.sh
###############################################################################
# SPDX-FileComment: Set up apps
#
# SPDX-FileCopyrightText: Karel Zimmer <info@karelzimmer.nl>
# SPDX-License-Identifier: CC0-1.0
###############################################################################


###############################################################################
# Imports
###############################################################################

source kz_common.sh as kz


###############################################################################
# Constants
###############################################################################

readonly PROGRAM_NAME='kz-setup'
PROGRAM_DESC=$(gettext 'Set up apps')
readonly PROGRAM_DESC
readonly PROGRAM_LOGS="systemd-cat --identifier=$PROGRAM_NAME"

USAGE=$(gettext "Usage: kz setup [-a|--apps] [-b|--browse] [-c|--cat]
                [-f|--file <file>]... [-g|--gui] [-r|--reset]
                [-h|--help] [-m|--manual] [-u|--usage] [-v|--version]
                [--] [<app>...]")
readonly USAGE

HELP="$(gettext "Usage: kz setup [<options>] [--] [<arguments>]")

$PROGRAM_DESC.

$(gettext 'Options:')
$(gettext "  Mandatory arguments to long options are mandatory for short \
options too.")

$(gettext '  -a, --apps     show list of apps')
$(gettext '  -b, --browse   browse setup files')
$(gettext '  -c, --cat      show contents of command file')
$(gettext "  -f, --file <file>
                 process specified setup files")
$(gettext '  -g, --gui      run in graphical mode,')
$(gettext '                 requires a desktop environment')
$(gettext '  -r, --reset    set apps on default values')
$(gettext '  -h, --help     show this help text')
$(gettext '  -m, --manual   show manual page')
$(gettext '  -u, --usage    show a short usage summary')
$(gettext '  -v, --version  show program version')

$(gettext 'Arguments:')
$(gettext '  <app>          process specified apps')"
readonly HELP

readonly OPTIONS_SHORT='abcf:grhmuv'
readonly OPTIONS_LONG="apps,browse,cat,file:,gui,reset,help,manual,usage,\
version"

# To be like kz-install; there it is a global.
readonly on='on'


###############################################################################
# Globals
###############################################################################

declare OPTION_GUI=false
declare OPTION_RESET=false
declare LOGOUT=true
declare -A FAILED_APPS=()


###############################################################################
# Functions
###############################################################################

# This function performs the script actions, such as checking the input.
function process() {
    local -A app_arguments=()
    local -a setup_files=()
    local -i setup_file_num=0
    local argument_app=false
    local command_file=''
    local err_flag=false
    local option_apps=false
    local option_browse=false
    local option_cat=false
    local option_file=false
    local reset='reset'
    local setup='setup'
    local setup_file_default_gpg=''
    local setup_file_default=/usr/bin/$PROGRAM_NAME.sh
    local setup_file=''
    local text=''

    check_input "$@"

    if ! $option_file; then
        setup_files[++setup_file_num]=$setup_file_default
        # Setup commands in gpg file.
        setup_file_default_gpg=\
$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX-decryptd.sh.gpg")
        gpg --import                        \
            /usr/share/kz/kz-public-key.gpg \
            2> >($PROGRAM_LOGS)
        gpg --decrypt                       \
            /usr/bin/kz-setup.sh.gpg        \
            2> >($PROGRAM_LOGS)             > "$setup_file_default_gpg"
        setup_files[++setup_file_num]=$setup_file_default_gpg
    fi

    for setup_file in "${setup_files[@]}"; do
        if [[ ! -f $setup_file ]]; then
            text=$(eval_gettext "Setup file '\$setup_file' not found.")
            kz.errmsg "text"
            err_flag=true
        fi
    done
    if $err_flag; then
        exit 1
    fi

    if $option_browse; then
        process_option_browse
        exit 0
    fi

    if $option_apps; then
        process_option_apps
        exit 0
    fi

    command_file=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX-commands.sh")

    if $argument_app; then
        process_argument_app
    else
        process_setup_file_by_hostname
    fi

    if $option_cat; then
        process_option_cat
        exit 0
    fi

    setup_apps
}


# This function checks the script input.
function check_input() {
    local parsed=''
    local program_name=${PROGRAM_NAME/kz-/kz }

    parsed=$(getopt --alternative                       \
                    --options       "$OPTIONS_SHORT"    \
                    --longoptions   "$OPTIONS_LONG"     \
                    --name          "$program_name"     \
                    --              "$@")               ||
                    {
                        kz.infomsg "$USAGE"
                        exit 1
                    }
    eval set -- "$parsed"
    unset parsed

    process_options "$@"
}


# This function handles the script options and arguments.
function process_options() {
    local program_name=${PROGRAM_NAME/kz-/kz }
    local text=''

    while true; do
        case $1 in
            -a | --apps )
                option_apps=true
                shift
                ;;
            -b | --browse )
                option_browse=true
                shift
                ;;
            -c | --cat )
                option_cat=true
                shift
                ;;
            -f | --file )
                option_file=true
                setup_files[++setup_file_num]=$2
                shift 2
                ;;
            -g | --gui )
                if ! [[ ${DISPLAY-} ]]; then
                    text="$program_name: $1: \
$(gettext 'no desktop environment available')
$USAGE"
                    kz.infomsg "$text"
                    exit 1
                fi
                OPTION_GUI=true
                shift
                ;;
            -r | --reset )
                OPTION_RESET=true
                setup='Reset'
                reset='Setup'
                shift
                ;;
            -h | --help )
                kz.process_option_help
                exit 0
                ;;
            -m | --manual )
                kz.process_option_manual
                exit 0
                ;;
            -u | --usage )
                kz.process_option_usage
                exit 0
                ;;
            -v | --version )
                kz.process_option_version
                exit 0
                ;;
            -- )
                shift
                break
                ;;
            * )
                text="$PROGRAM_NAME: getopt: $(gettext 'internal error')"
                kz.errmsg "text"
                exit 1
                ;;
        esac
    done

    if [[ $* ]]; then
        argument_app=true
        LOGOUT=false
        while [[ $* ]]; do
            app_arguments[$1]=$1
            shift
        done
    fi
}


# This function browses through the setup file.
function process_option_browse() {
    less --no-init --quit-if-one-screen "${setup_files[@]}"
}


# This function shows the available apps from the setup file.
function process_option_apps() {
    local apps=''
    local text=''

    text="$(gettext 'The following apps are available:')

$(gettext 'NUM  APP')
"
    apps=$(
        grep    "#.*$setup.*$on"        \
                "${setup_files[@]}"     |
        tr      --squeeze-repeats       \
                '[:space:]'             |
        cut     --delimiter=' '         \
                --fields=3              |
        sort    --unique                |
        nl      --number-width=3        \
                --number-format=rn      \
                --number-separator='  ' \
                --body-numbering=a      || true
        )

    if [[ $apps ]]; then
        text+="$apps

$(gettext 'Use "kz setup <app>..." to set up the apps.')
$(gettext 'Use "kz setup --cat" to view the contents of the setup file.')
$(gettext "Use \"kz setup --cat <app>...\" to view the contents of the apps \
setup file.")
$(gettext "Use \"kz setup --browse\" to view the contents of the default \
setup file.")"
    else
        text+="$(gettext '  0  No apps found.')

$USAGE"
    fi
    kz.infomsg "$text"
}


# This function processes argument <app>.
function process_argument_app() {
    local app_argument=''

    for app_argument in "${app_arguments[@]}"; do
        process_setup_file_by_app_argument
    done
}


# This function generates the command file from the setup file and filters by
# <app>.
function process_setup_file_by_app_argument() {
    local app_match=false
    local input_record=''
    local no_app_match=true
    local text=''

    while read -r input_record; do
        case $input_record in
            '' )
                # Skip empty line.
                continue
                ;;
            '#'*$setup*[[:space:]]"$app_argument"[[:space:]]*$on* )
                # Add matching app record to command file.
                app_match=true
                no_app_match=false
                printf '\n%s\n' "$input_record" >> "$command_file"
                ;;
            '#'*$setup*$on* | '#'*$reset*$on* )
                # Skip mismatched app record.
                app_match=false
                ;;
            * )
                if $app_match; then
                    # Add record to command file.
                    printf '%s\n' "$input_record" >> "$command_file"
                fi
                ;;
        esac
    done < <(cat "${setup_files[@]}")

    if $no_app_match; then
        text=$(eval_gettext "App '\$app_argument' not found")
        kz.errmsg "text"
    else
        # Add extra empty line  to command file.
        printf '\n' >> "$command_file"
    fi
}


# This function generates the command file from the setup file and filters by
# host.
function process_setup_file_by_hostname() {
    local host_match=false
    local input_record=''

    while read -r input_record; do
        case $input_record in
            '' )
                # Skip empty line.
                continue
                ;;
            '#'*$setup*$on*'*' | '#'*$setup*$on*$HOSTNAME* )
                # Add matching app record to command file.
                host_match=true
                printf '\n%s\n' "$input_record" >> "$command_file"
                ;;
            '#'*$setup*$on* | '#'*$reset*$on* )
                # Skip mismatched app record.
                host_match=false
                ;;
            * )
                if $host_match; then
                    # Add record to command file.
                    printf '%s\n' "$input_record" >> "$command_file"
                fi
                ;;
        esac
    done < <(cat "${setup_files[@]}")
    # Add extra empty line  to command file.
    printf '\n' >> "$command_file"
}


# This function displays the contents of the command file.
function process_option_cat() {
    less --no-init --quit-if-one-screen "$command_file"
}


# This function starts setting up the apps.
function setup_apps() {
    local -i app_tot_num=0
    local text=''
    local title=''

    app_tot_num=$(grep --count "#.*$setup.*$on" "$command_file" || true)
    if [[ $app_tot_num -eq 0 ]]; then
        text=$(gettext 'No commands to execute.' )
        kz.infomsg "$text"
        exit 0
    fi

    title=$(gettext 'Set up apps')
    text=$(gettext 'Preparing set up')
    kz.debugmsg "$title"...

    if $OPTION_GUI; then
        # With '|& zenity --progress' global variables from called functions
        # are not passed, hence the process substitution with '> >(zenity...)'.
        process_command_file > >(
            zenity  --progress              \
                    --pulsate               \
                    --auto-close            \
                    --no-cancel             \
                    --width     700         \
                    --height    50          \
                    --title     "$title"    \
                    --text      "text"     2> /dev/null
            )
    else
        process_command_file
    fi
}


# This function reads commands from the command file for further processing.
function process_command_file() {
    local -i app_seq_num=0
    local -i cmd_seq_num=0
    local app_name_line=''
    local app_name=''
    local command_record=''
    local text=''

    if ! $OPTION_GUI; then
        text="$(gettext 'NUM/TOT  APP')
         $(gettext 'COMMAND')..."
        kz.infomsg "$text"
    fi

    while read -r command_record; do
        case $command_record in
            '#'*$setup*$on* )
                # App record.
                app_name=$(
                    printf '%s\n' "$command_record"     |
                    tr --squeeze-repeats '[:space:]'    |
                    cut --delimiter=' ' --fields=3
                    )
                (( ++app_seq_num ))
                cmd_seq_num=0
                printf  -v app_name_line    \
                        "%3d/%-3d  %s"      \
                        "$app_seq_num"      \
                        "$app_tot_num"      \
                        "$app_name"
                ;;
            '' | '#'* )
                # Empty or comment line.
                continue
                ;;
            * )
                # Process command record.
                execute_command "$command_record"
                ;;
        esac
    done < "$command_file"
}


# This function reports and executes a command from the command file.
function execute_command() {
    local -i cmd_dis_len=0
    local -i cmd_dis_max=0
    local cmd_dis=''
    local cmd=${1:-unknown}

    (( ++cmd_seq_num ))

    if $OPTION_GUI; then
        if [[ $cmd_seq_num -eq 1 ]]; then
            kz.debugmsg "$app_name_line"
        fi
        printf '%s\n' "#$app_name_line\n\n$cmd"
    else
        if [[ $cmd_seq_num -eq 1 ]]; then
            kz.infomsg "$app_name_line"
        fi
        # Ellipsize terminal output.
        # Width 9 characters less, 9 for leading spaces.
        cmd_dis_max=$(( $(tput cols) - 9 ))
        if [[ ${#cmd} -gt $cmd_dis_max ]]; then
            # Width 12 characters less, 9 for leading spaces and 3 for trailing
            # ellipsis.
            cmd_dis_len=$(( $(tput cols) - 12 ))
            cmd_dis=${cmd:0:cmd_dis_len}...
        else
            cmd_dis=$cmd
        fi
        kz.infomsg "         $cmd_dis"
    fi

    kz.debugmsg "$cmd"
    ERREXIT=false
    eval "$cmd" &> >($PROGRAM_LOGS) || FAILED_APPS[$app_name]=$app_name
    ERREXIT=true
}


# This function controls the termination of the script.
function term() {
    local operation=''
    local text=''

    if [[ ${FAILED_APPS[*]} ]]; then
        text="$(gettext "The set up of the following apps contains errors:")
${FAILED_APPS[*]}

$(eval_gettext "Use \"journalctl --boot --id=\$PROGRAM_NAME\" in Terminal to \
view log messages.")

$(gettext "Try to set up the apps again.")"
        kz.errmsg "text"
        exit 1
    fi

    operation=$(gettext 'set up')

    if $OPTION_RESET; then
        # shellcheck disable=SC2034
        operation=$(gettext 'reset')
    fi
    text=$(eval_gettext "Apps \$operation completed.")

    if $LOGOUT; then

        if [[ ${DISPLAY-} ]]; then
            text+="

$(gettext "You will now be logged out of the computer to finish setting up \
the apps and changing user settings.")"
        else
            text+="

$(gettext "Type 'logout' to log out of the computer to finish setting up the \
apps and changing user settings.")"
        fi
        kz.infomsg "$text"

        if [[ ${DISPLAY-} ]]; then
            $OPTION_GUI || kz.wait_for_enter

            if type gnome-session &> /dev/null; then
                gnome-session-quit --logout --no-prompt
            elif type ksmserver &> /dev/null; then
                qdbus org.kde.ksmserver /KSMServer logout 0 0 0
            elif type lxqt-session &> /dev/null; then
                lxqt-leave --logout
            elif type mate-session &> /dev/null; then
                mate-session-save --logout
            elif type xfce4-session &> /dev/null; then
                xfce4-session-logout --logout
            else
                text='No logout command available.'
                kz.debugmsg "text"
                text=$(gettext 'Log out of the computer yourself.')
                kz.infomsg "$text"
            fi
        fi
    else
        kz.infomsg "$text"
    fi

    exit 0
}


###############################################################################
# Main
###############################################################################

function main() {
    kz.init "$@"
    process "$@"
    term
}

main "$@"
