#!/usr/bin/bash
# shellcheck source=kz_common.sh
###############################################################################
# Installation menu.
#
# Written by Karel Zimmer <info@karelzimmer.nl>, CC0 1.0 Universal
# <https://creativecommons.org/publicdomain/zero/1.0>, 2015-2023.
###############################################################################

###############################################################################
# Import
###############################################################################

PROGRAM_PATH=$(cd "$(dirname "$(realpath "$0")")" && pwd)
readonly PROGRAM_PATH
source "$PROGRAM_PATH"/kz_common.sh 2> >(systemd-cat --identifier=kz_common.sh)


###############################################################################
# Constants
###############################################################################

readonly PROGRAM_NAME='kz-menu'
PROGRAM_DESC=$(gettext 'Installation menu')
readonly PROGRAM_DESC
readonly DISPLAY_NAME=${PROGRAM_NAME/kz-/kz }

USAGE=$(eval_gettext "Usage: \$DISPLAY_NAME [-g|--gui] \$OPTIONS_USAGE")
readonly USAGE
HELP="$(eval_gettext "Usage: \$DISPLAY_NAME [OPTION...]")

$PROGRAM_DESC.

$(gettext 'Options:')
  -g, --gui      $(gettext 'starts in graphics mode')
$OPTIONS_HELP"
readonly HELP
readonly X_OPTIONS_SHORT='g'
readonly X_OPTIONS_LONG=',gui'

MENU1_TITLE=$(gettext 'Installation menu')
readonly MENU1_TITLE
readonly MENU1_HEAD="     $MENU1_TITLE"
readonly -a MENU1_ACTIONS=(
            [1]="$(gettext 'Prepare installation')"
                "$(gettext 'Perform installation')"
                "$(gettext 'Finish installation')"
                "$(gettext 'Provision user')"
                "$(gettext 'Command menu')"
                "$(gettext 'Stop')"
            )
readonly -a MENU1_COMMANDS=(
            [1]="$(gettext 'Checklist chapter 1')"
                "$(gettext 'Checklist chapter 2')"
                "$(gettext 'Checklist chapter 3')"
                "$(gettext 'Checklist chapter 4')"
                "$(gettext 'Show command menu')"
                "$(gettext 'Exit menu')"
            )
readonly MENU1_LINES=${#MENU1_ACTIONS[@]}

MENU2_TITLE=$(gettext 'Command menu')
readonly MENU2_TITLE
readonly MENU2_HEAD="     $MENU2_TITLE"
readonly -a MENU2_ACTIONS=(
            [1]="$(gettext 'Show WiFi information')"
                "$(gettext 'Make backup')"
                "$(gettext 'Add users')"
                "$(gettext 'Install apps')"
                "$(gettext 'Restore backup')"
                "$(gettext 'Set user photo')"
                "$(gettext 'Set up apps')"
                "$(gettext 'Stop')"
            )
readonly -a MENU2_COMMANDS=(
            [1]='kz wifi'
                'kz backup'
                "$(gettext 'Manually')"
                'kz install'
                'kz restore'
                "$(gettext 'Manually')"
                'kz setup'
                "$(gettext 'Exit menu')"
            )
readonly MENU2_LINES=${#MENU2_ACTIONS[@]}


###############################################################################
# Variables
###############################################################################

declare execute_command=false
declare -a rows=()
declare option_gui=false


###############################################################################
# Functions
###############################################################################

# This function handles the script options and arguments.
function check_input {
    local parsed=''

    parsed=$(
        getopt  --alternative                                       \
                --options       "$OPTIONS_SHORT$X_OPTIONS_SHORT"    \
                --longoptions   "$OPTIONS_LONG$X_OPTIONS_LONG"      \
                --name          "$DISPLAY_NAME"                     \
                --              "$@"
        ) || ( printf '%s\n' "$USAGE_LINE"; exit $ERROR )
    eval set -- "$parsed"

    process_common_options "$@"

    while true; do
        case $1 in
            -g|--gui)
                if [[ $EDITION = 'server' ]]; then
                    printf  "$DISPLAY_NAME: $1: %s\n$USAGE_LINE\n" \
                            "$(gettext 'not allowed on a server')"
                    exit $ERROR
                fi
                option_gui=true
                reset_terminal_attributes
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -n "$*" ]]; then
        printf  "$DISPLAY_NAME: $*: %s\n$USAGE_LINE\n" \
                "$(gettext 'arguments are not allowed')"
        exit $ERROR
    fi
}


# This function processes the script options and arguments.
function process_input {
    if $option_gui; then
        process_menu1_gui
    else
        process_menu1_tui
    fi
}


# This function shows and processes menu #1 in GUI mode.
function process_menu1_gui {
    while true; do
        title=$MENU1_TITLE
        REPLY=$(
            zenity  --list                                                  \
                    --radiolist                                             \
                    --width         500                                     \
                    --height        240                                     \
                    --title         "$title"                                \
                    --text          "$(gettext 'Select a choice:')"         \
                    --ok-label      "$(gettext 'Continue')"                 \
                    --cancel-label  "$(gettext 'Exit')"                     \
                    --column        "$(gettext 'Choice')"                   \
                    --column        "$(gettext 'No.')"                      \
                    --column        "$(gettext 'Action')"                   \
                    --column        "$(gettext 'Explanation')"              \
                    TRUE  1 "${MENU1_ACTIONS[1]}" "${MENU1_COMMANDS[1]}"    \
                    FALSE 2 "${MENU1_ACTIONS[2]}" "${MENU1_COMMANDS[2]}"    \
                    FALSE 3 "${MENU1_ACTIONS[3]}" "${MENU1_COMMANDS[3]}"    \
                    FALSE 4 "${MENU1_ACTIONS[4]}" "${MENU1_COMMANDS[4]}"    \
                    FALSE 5 "${MENU1_ACTIONS[5]}" "${MENU1_COMMANDS[5]}"    \
                    2> >($logcmd)
            ) || exit $OK
        process_menu1_choice
    done
}


# This function shows and processes menu #1 in TUI mode.
function process_menu1_tui {
    local menu1_action=''

    msg_info "$MENU1_HEAD
"
    for menu1_action in "${!MENU1_ACTIONS[@]}"; do
        printf  '%2s - %-25.25s - %s\n'             \
                "$menu1_action"                     \
                "${MENU1_ACTIONS[$menu1_action]}"   \
                "${MENU1_COMMANDS[$menu1_action]}"
    done
    msg_info ''

    while true; do
        read -rp "$(eval_gettext "Run number [1-\$MENU1_LINES]: ")"
        case $REPLY in
            *[^[:digit:]]*)
                continue
                ;;
            *)
                if [[ $REPLY -ge 1 && $REPLY -le $MENU1_LINES ]]; then
                    break
                else
                    continue
                fi
                ;;
        esac
    done
    process_menu1_choice
}


# This function processes menu #1 choice.
function process_menu1_choice {
    case $REPLY in
        1)
            process_menu1_choice1
            ;;
        2)
            process_menu1_choice2
            ;;
        3)
            process_menu1_choice3
            ;;
        4)
            process_menu1_choice4
            ;;
        5)
            process_menu2
            ;;
        6)
            exit $OK
            ;;
        *)
            msg_error "$(eval_gettext "Cannot handle this choice (\$REPLY).")"
            exit $ERROR
            ;;
    esac
}


# This function processes menu #1 choice #1.
function process_menu1_choice1 {
    title="${MENU1_ACTIONS[1]}"
    rows=(
        [1]="${MENU2_ACTIONS[1]}#${MENU2_COMMANDS[1]}"
            "${MENU2_ACTIONS[2]}#${MENU2_COMMANDS[2]}"
        )
    process_commands
}


# This function processes menu #1 choice #2.
function process_menu1_choice2 {
    title="${MENU1_ACTIONS[2]}"
    text="
$(gettext "Follow the steps as described in Checklist installation, Chapter 2.
Checklist installation can be found on the site https://karelzimmer.nl,
under Linux.

Roughly boils down to:
1. Download an image file (.iso).
2. Create a bootable Live USB stick or DVD.
3. Boot the computer from this USB stick or DVD.
4. Install Linux.")"
    msg_info "$text"
    if $option_gui; then
        wait_for_enter
    fi
}


# This function processes menu #1 choice #3.
function process_menu1_choice3 {
    title="${MENU1_ACTIONS[3]}"
    rows=(
        [1]="${MENU2_ACTIONS[3]}#${MENU2_COMMANDS[3]}"
            "${MENU2_ACTIONS[4]}#${MENU2_COMMANDS[4]}"
        )
    process_commands
}


# This function processes menu #1 choice #4.
function process_menu1_choice4 {
    title="${MENU1_ACTIONS[4]}"
    rows=(
        [1]="${MENU2_ACTIONS[5]}#${MENU2_COMMANDS[5]}"
            "${MENU2_ACTIONS[6]}#${MENU2_COMMANDS[6]}"
            "${MENU2_ACTIONS[7]}#${MENU2_COMMANDS[7]}"
        )
    process_commands
}


# This function processes menu #2.
function process_menu2 {
    if $option_gui; then
        process_menu2_gui
    else
        process_menu2_tui
    fi
}


# This function shows and processes menu #2 in GUI mode.
function process_menu2_gui {
    while true; do
        title=$MENU2_TITLE
        REPLY=$(
            zenity  --list                                                  \
                    --radiolist                                             \
                    --width         440                                     \
                    --height        290                                     \
                    --title         "$title"                                \
                    --text          "$(gettext 'Select a choice:')"         \
                    --ok-label      "$(gettext 'Continue')"                 \
                    --cancel-label  "$(gettext 'Back')"                     \
                    --column        "$(gettext 'Choice')"                   \
                    --column        "$(gettext 'No.')"                      \
                    --column        "$(gettext 'Action')"                   \
                    --column        "$(gettext 'Command')"                  \
                    TRUE  1 "${MENU2_ACTIONS[1]}" "${MENU2_COMMANDS[1]}"    \
                    FALSE 2 "${MENU2_ACTIONS[2]}" "${MENU2_COMMANDS[2]}"    \
                    FALSE 3 "${MENU2_ACTIONS[3]}" "${MENU2_COMMANDS[3]}"    \
                    FALSE 4 "${MENU2_ACTIONS[4]}" "${MENU2_COMMANDS[4]}"    \
                    FALSE 5 "${MENU2_ACTIONS[5]}" "${MENU2_COMMANDS[5]}"    \
                    FALSE 6 "${MENU2_ACTIONS[6]}" "${MENU2_COMMANDS[6]}"    \
                    FALSE 7 "${MENU2_ACTIONS[7]}" "${MENU2_COMMANDS[7]}"    \
                    2> >($logcmd)
            ) || break
        process_menu2_choice
    done
}


# This function shows and processes menu #2 in TUI mode.
function process_menu2_tui {
    local menu2_action=''

    msg_info "$MENU2_HEAD
"
    for menu2_action in "${!MENU2_ACTIONS[@]}"; do
        printf  '%2s - %-25.25s - %s\n'             \
                "$menu2_action"                     \
                "${MENU2_ACTIONS[$menu2_action]}"   \
                "${MENU2_COMMANDS[$menu2_action]}"
    done
    msg_info ''

    while true; do
        read -rp "$(eval_gettext "Run number [1-\$MENU2_LINES]: ")"
        case $REPLY in
            *[^[:digit:]]*)
                continue
                ;;
            *)
                if [[ $REPLY -ge 1 && $REPLY -le $MENU2_LINES ]]; then
                    break
                else
                    continue
                fi
                ;;
        esac
    done
    process_menu2_choice
}


# This function processes menu #2 choice.
function process_menu2_choice {
    if [[ $REPLY -ge 1 && $REPLY -le $((MENU2_LINES -1)) ]]; then
        title="${MENU2_ACTIONS[$REPLY]}"
        rows=(
            [1]="${MENU2_ACTIONS[$REPLY]}#${MENU2_COMMANDS[$REPLY]}"
            )
        process_commands
    elif [[ $REPLY -eq $MENU2_LINES ]]; then
        exit $OK
    else
        msg_error "$(eval_gettext "Cannot handle this choice (\$REPLY).")"
        exit $ERROR
    fi
}


# This function processes the command corresponding to the choice made.
function process_commands {
    local action=''
    local command=''
    local -i row=0

    if [[ ${#rows[@]} -eq 1 ]]; then
        execute_command=true
    else
        show_commands_before_execution
    fi
    if $execute_command; then
        for row in "${!rows[@]}"; do
            action=$(
                printf '%s' "${rows[$row]}" | cut --delimiter='#' --fields=1
                )
            command=$(
                printf '%s' "${rows[$row]}" | cut --delimiter='#' --fields=2
                )
            title=$action
            execute_command
        done
    fi
}


# This function shows the command before it is executed.
function show_commands_before_execution {
    local action=''
    local command=''
    local -i row=0
    local prompt=''

    text="$(gettext 'The following will be executed:')
"
    for row in "${!rows[@]}"; do
        action=$(
            printf '%s' "${rows[$row]}" | cut --delimiter='#' --fields=1
            )
        command=$(
            printf '%s' "${rows[$row]}" | cut --delimiter='#' --fields=2
            )
        text+="
$row. $action ($command)"
    done
    text+='
'
    prompt="$(gettext 'Proceed?')"
    if $option_gui; then
        text+="
$prompt"
        if zenity   --question                          \
                    --no-markup                         \
                    --width         600                 \
                    --height        100                 \
                    --title         "$title"            \
                    --text          "$text"             \
                    --ok-label      "$(gettext 'Yes')"  \
                    --cancel-label  "$(gettext 'No')"   2> >($logcmd); then
            execute_command=true
        else
            execute_command=false
        fi
    else
        msg_info "
$text"
        while true; do
            read -rp "$(eval_gettext "\$prompt [Y/n]: ")"
            case $REPLY in
                [YyJj]*|'')
                    execute_command=true
                    break
                    ;;
                [Nn]*)
                    execute_command=false
                    break
                    ;;
                *)
                    continue
                    ;;
            esac
        done
    fi
}


# This function executes the command.
function execute_command {
    local -i rc=0
    local cmd=''
    local row=''
    local gui_option=''

    printf '\n'

    # Handle manual actions.
    if [[ $command = $(gettext 'Manually') ]]; then
        manual_actions
        return $OK
    fi

    # Process (automatic) commands.
    row=${command/kz /kz-}
    cmd=$(
        printf '%s' "$row" | cut --delimiter=' ' --fields=1
        )
    arg=$(
        printf '%s' "$row" | cut --delimiter=' ' --fields=2- --only-delimited
        )
    if $option_gui; then
        gui_option='--gui'
    fi
    "$PROGRAM_PATH/$cmd" "$arg" $gui_option -- || rc=$?
    msg_log "$command: rc=$rc"
    if $option_gui; then
        wait_for_enter
    fi
}


# This function shows the manual actions to be performed.
function manual_actions {
    if [[ $title = $(gettext 'Add users') ]]; then
        text="$(gettext 'Add users'):

$(gettext "Add any additional users with the following steps.

1. Press the Super key[1], type 'user' and click behind Settings on Users.
2. Click Unlock and enter password.
3. Click Add User.
4. Choose Account Type Standard or Admin.
5. Complete the screen and click Add.
6. Close the Users screen.

[1] The Super key is the Windows key, Command key (Apple), or Magnifier key \
(Chromebook).")"
        msg_info "$text"
        if $option_gui; then
            wait_for_enter
        fi
    elif [[ $title = $(gettext 'Set user photo') ]]; then
        text="$(gettext 'Set user photo'):

$(gettext 'No user photo was found when backing up.')"
        if type xdg-user-dir &> /dev/null; then
            if [[ -f $(xdg-user-dir PICTURES)/$(gettext 'Userphoto') ]]; then
                text="$(gettext 'Set user photo'):

$(gettext "1. Press the Super key[1], type 'user' and click behind Settings \
on Users.
2. Click the image for the user.
3. Click Select a file.
4. Select Userphoto in Personal folder / Pictures.
5. Close the Users screen.

[1] The Super key is the Windows key, Command key (Apple), or Magnifier key \
(Chromebook).")"
                msg_info "$text"
            else
                msg_info "$text"
            fi
        else
            msg_info "$text"
        fi
        if $option_gui; then
            wait_for_enter
        fi
    fi
}


# This function controls the termination of the script.
function term_script {
    exit $OK
}


###############################################################################
# Main Script
###############################################################################

function main {
    init_script "$@"
    check_input "$@"
    process_input
    term_script
}

main "$@"
