#!/usr/bin/bash
# shellcheck source=kz_common.sh disable=SC2155
###############################################################################
# Installation menu.
#
# Written by Karel Zimmer <info@karelzimmer.nl>, CC0 1.0 Universal
# <https://creativecommons.org/publicdomain/zero/1.0>, 2015-2024.
###############################################################################


###############################################################################
# Import
###############################################################################

source "$(dirname "$0")"/kz_common.sh


###############################################################################
# Constants
###############################################################################

readonly    PROGRAM_NAME='kz-menu'
readonly    PROGRAM_DESC=$(gettext 'Installation menu')
readonly    DISPLAY_NAME=${PROGRAM_NAME/kz-/kz }

readonly    USAGE=$(eval_gettext "Usage: \$DISPLAY_NAME [-g|--gui] \$OPTIONS_U\
SAGE")
readonly    HELP="$(eval_gettext "Usage: \$DISPLAY_NAME [OPTION...]")

$PROGRAM_DESC.

$(gettext 'Options:')
$(gettext '  -g, --gui      starts in graphical mode')
$OPTIONS_HELP"

readonly    X_OPTIONS_SHORT='g'
readonly    X_OPTIONS_LONG=',gui'

readonly    PROGRAM_PATH=$MODULE_PATH

            MENU1_TITLE=$(gettext 'Installation menu')
readonly    MENU1_TITLE
readonly    MENU1_HEAD="------------------ $MENU1_TITLE ------------------"
readonly -a MENU1_ACTIONS=(
            [1]="$(gettext 'Prepare installation')"
                "$(gettext 'Perform installation')"
                "$(gettext 'Finish installation')"
                "$(gettext 'Provision user')"
                "$(gettext 'Command menu')"
                "$(gettext 'Exit')"
            )
readonly -a MENU1_COMMANDS=(
            [1]="$(gettext 'Checklist chapter 1')"
                "$(gettext 'Checklist chapter 2')"
                "$(gettext 'Checklist chapter 3')"
                "$(gettext 'Checklist chapter 4')"
                "$(gettext 'Show command menu')"
                "$(gettext 'Exit menu')"
            )
readonly    MENU1_LINES=${#MENU1_ACTIONS[@]}

            MENU2_TITLE=$(gettext 'Command menu')
readonly    MENU2_TITLE
readonly    MENU2_HEAD="--------------- $MENU2_TITLE ---------------"
readonly -a MENU2_ACTIONS=(
            [1]="$(gettext 'Show WiFi information')"
                "$(gettext 'Make backup')"
                "$(gettext 'Add users')"
                "$(gettext 'Install apps')"
                "$(gettext 'Restore backup')"
                "$(gettext 'Set user photo')"
                "$(gettext 'Set up apps')"
                "$(gettext 'Back')"
            )
readonly -a MENU2_COMMANDS=(
            [1]='kz wifi'
                'kz backup'
                "$(gettext '"manually"')"
                'kz install'
                'kz restore'
                "$(gettext '"manually"')"
                'kz setup'
                "$(gettext 'N/A')"
            )
readonly    MENU2_LINES=${#MENU2_ACTIONS[@]}


###############################################################################
# Variables
###############################################################################

declare     execute_command=false
declare -a  rows=()


###############################################################################
# Functions
###############################################################################

# This function handles the script options and arguments.
function check_input {
    local       parsed=''
    local   -i  parsed_rc=0

    parsed=$(
        getopt  --alternative                                       \
                --options       "$OPTIONS_SHORT$X_OPTIONS_SHORT"    \
                --longoptions   "$OPTIONS_LONG$X_OPTIONS_LONG"      \
                --name          "$DISPLAY_NAME"                     \
                --              "$@"
        ) || parsed_rc=$?
    if [[ $parsed_rc -ne $OK ]]; then
        printf '%s\n' "$USAGE_LINE"
        exit $ERROR
    fi
    eval set -- "$parsed"

    process_common_options "$@"

    while true; do
        case $1 in
            -g|--gui)
                if [[ $EDITION = 'server' ]]; then
                    printf  "$DISPLAY_NAME: $1: %s\n$USAGE_LINE\n"  \
                            "$(gettext 'not allowed on a server')"
                    exit $ERROR
                fi
                option_gui=true
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -n "$*" ]]; then
        printf  "$DISPLAY_NAME: $*: %s\n$USAGE_LINE\n"  \
                "$(gettext 'arguments are not allowed')"
        exit $ERROR
    fi
}


# This function processes the script options and arguments.
function process_input {
    if $option_gui; then
        process_menu1_gui
    else
        process_menu1_tui
    fi
}


# This function shows and processes menu #1 in GUI mode.
function process_menu1_gui {
    while true; do
        title=$MENU1_TITLE
        REPLY=$(
            zenity  --list                                                  \
                    --radiolist                                             \
                    --width         510                                     \
                    --height        240                                     \
                    --title         "$title"                                \
                    --text          "$(gettext 'Select a choice:')"         \
                    --ok-label      "$(gettext 'Continue')"                 \
                    --cancel-label  "$(gettext 'Exit')"                     \
                    --column        "$(gettext 'CHOICE')"                   \
                    --column        "$(gettext 'NUM')"                      \
                    --column        "$(gettext 'ACTION')"                   \
                    --column        "$(gettext 'EXPLANATION')"              \
                    TRUE  1 "${MENU1_ACTIONS[1]}" "${MENU1_COMMANDS[1]}"    \
                    FALSE 2 "${MENU1_ACTIONS[2]}" "${MENU1_COMMANDS[2]}"    \
                    FALSE 3 "${MENU1_ACTIONS[3]}" "${MENU1_COMMANDS[3]}"    \
                    FALSE 4 "${MENU1_ACTIONS[4]}" "${MENU1_COMMANDS[4]}"    \
                    FALSE 5 "${MENU1_ACTIONS[5]}" "${MENU1_COMMANDS[5]}"    \
                    2> >($LOGCMD)
            ) || exit $OK
        process_menu1_choice
    done
}


# This function shows and processes menu #1 in TUI mode.
function process_menu1_tui {
    local   menu1_action=''

    while true; do
        printf '\n%s\n\n' "$MENU1_HEAD"
            printf  '%3s  %-24s  %s\n'      \
                    "$(gettext 'NUM')"      \
                    "$(gettext 'ACTION')"   \
                    "$(gettext 'EXPLANATION')"
        for menu1_action in "${!MENU1_ACTIONS[@]}"; do
            printf  '%3s  %-24s  %s\n'                  \
                    "$menu1_action"                     \
                    "${MENU1_ACTIONS[$menu1_action]}"   \
                    "${MENU1_COMMANDS[$menu1_action]}"
        done
        printf '\n'
        read -rp "$(eval_gettext "Run number [1-\$MENU1_LINES]: ")"
        case $REPLY in
            *[^[:digit:]]*)
                continue
                ;;
            *)
                if [[ $REPLY -ge 1 && $REPLY -le $MENU1_LINES ]]; then
                    process_menu1_choice
                else
                    continue
                fi
                ;;
        esac
    done
}


# This function processes menu #1 choice.
function process_menu1_choice {
    case $REPLY in
        1)
            process_menu1_choice1
            ;;
        2)
            process_menu1_choice2
            ;;
        3)
            process_menu1_choice3
            ;;
        4)
            process_menu1_choice4
            ;;
        5)
            process_menu2
            ;;
        6)
            exit $OK
            ;;
        *)
            msg_error "$(eval_gettext "Cannot handle this choice (\$REPLY).")"
            exit $ERROR
            ;;
    esac
}


# This function processes menu #1 choice #1.
function process_menu1_choice1 {
    title=${MENU1_ACTIONS[1]}
    rows=(
        [1]="${MENU2_ACTIONS[1]}#${MENU2_COMMANDS[1]}"
            "${MENU2_ACTIONS[2]}#${MENU2_COMMANDS[2]}"
        )
    process_commands
}


# This function processes menu #1 choice #2.
function process_menu1_choice2 {
    title=${MENU1_ACTIONS[2]}
    # shellcheck disable=SC2034
    local   website_url=https://karelzimmer.nl
    text="
$(eval_gettext "Follow the steps as described in Checklist installation, Chapt\
er 2.
Checklist installation can be found on \$website_url, under Linux.

Roughly boils down to:
1. Download a CD image file (.iso).
2. Create a bootable USB stick.
3. Boot the computer from this USB stick.
4. Install Linux.")"
    msg_info "$text"
}


# This function processes menu #1 choice #3.
function process_menu1_choice3 {
    title=${MENU1_ACTIONS[3]}
    rows=(
        [1]="${MENU2_ACTIONS[3]}#${MENU2_COMMANDS[3]}"
            "${MENU2_ACTIONS[4]}#${MENU2_COMMANDS[4]}"
        )
    process_commands
}


# This function processes menu #1 choice #4.
function process_menu1_choice4 {
    title=${MENU1_ACTIONS[4]}
    rows=(
        [1]="${MENU2_ACTIONS[5]}#${MENU2_COMMANDS[5]}"
            "${MENU2_ACTIONS[6]}#${MENU2_COMMANDS[6]}"
            "${MENU2_ACTIONS[7]}#${MENU2_COMMANDS[7]}"
        )
    process_commands
}


# This function processes menu #2.
function process_menu2 {
    if $option_gui; then
        process_menu2_gui
    else
        process_menu2_tui
    fi
}


# This function shows and processes menu #2 in GUI mode.
function process_menu2_gui {
    while true; do
        title=$MENU2_TITLE
        REPLY=$(
            zenity  --list                                                  \
                    --radiolist                                             \
                    --width         450                                     \
                    --height        290                                     \
                    --title         "$title"                                \
                    --text          "$(gettext 'Select a choice:')"         \
                    --ok-label      "$(gettext 'Continue')"                 \
                    --cancel-label  "$(gettext 'Back')"                     \
                    --column        "$(gettext 'CHOICE')"                   \
                    --column        "$(gettext 'NUM')"                      \
                    --column        "$(gettext 'ACTION')"                   \
                    --column        "$(gettext 'COMMAND')"                  \
                    TRUE  1 "${MENU2_ACTIONS[1]}" "${MENU2_COMMANDS[1]}"    \
                    FALSE 2 "${MENU2_ACTIONS[2]}" "${MENU2_COMMANDS[2]}"    \
                    FALSE 3 "${MENU2_ACTIONS[3]}" "${MENU2_COMMANDS[3]}"    \
                    FALSE 4 "${MENU2_ACTIONS[4]}" "${MENU2_COMMANDS[4]}"    \
                    FALSE 5 "${MENU2_ACTIONS[5]}" "${MENU2_COMMANDS[5]}"    \
                    FALSE 6 "${MENU2_ACTIONS[6]}" "${MENU2_COMMANDS[6]}"    \
                    FALSE 7 "${MENU2_ACTIONS[7]}" "${MENU2_COMMANDS[7]}"    \
                    2> >($LOGCMD)
            ) || break
        process_menu2_choice
    done
}


# This function shows and processes menu #2 in TUI mode.
function process_menu2_tui {
    local   menu2_action=''

    while true; do
        printf '\n%s\n\n' "$MENU2_HEAD"
        printf  '%3s  %-25s  %s\n'      \
                "$(gettext 'NUM')"      \
                "$(gettext 'ACTION')"   \
                "$(gettext 'COMMAND')"
        for menu2_action in "${!MENU2_ACTIONS[@]}"; do
            printf  '%3s  %-25s  %s\n'                  \
                    "$menu2_action"                     \
                    "${MENU2_ACTIONS[$menu2_action]}"   \
                    "${MENU2_COMMANDS[$menu2_action]}"
        done
        printf '\n'
        read -rp "$(eval_gettext "Run number [1-\$MENU2_LINES]: ")"
        case $REPLY in
            *[^[:digit:]]*)
                continue
                ;;
            *)
                if [[ $REPLY -ge 1 && $REPLY -le $MENU2_LINES ]]; then
                    process_menu2_choice
                else
                    continue
                fi
                ;;
        esac
    done
}


# This function processes menu #2 choice.
function process_menu2_choice {
    if [[ $REPLY -ge 1 && $REPLY -le $((MENU2_LINES -1)) ]]; then
        title=${MENU2_ACTIONS[$REPLY]}
        rows=(
            [1]="${MENU2_ACTIONS[$REPLY]}#${MENU2_COMMANDS[$REPLY]}"
            )
        if [[ ${MENU2_COMMANDS[$REPLY]} = $(gettext '"manually"') ]]; then
            manual_actions
            return $OK
        else
            process_commands
        fi
    elif [[ $REPLY -eq $MENU2_LINES ]]; then
        process_menu1_tui
    else
        msg_error "$(eval_gettext "Cannot handle this choice (\$REPLY).")"
        exit $ERROR
    fi
}


# This function shows the manual actions to be performed.
function manual_actions {
    if [[ $title = $(gettext 'Add users') ]]; then
        text="$(gettext 'Add users'):

$(gettext "Add any additional users with the following steps.

1. Press the Super key[1], type 'user' and click behind Settings on Users.
2. Click Unlock and enter password.
3. Click Add User.
4. Choose Account Type Standard or Admin.
5. Complete the screen and click Add.
6. Close the Users screen.

[1] The Super key is the Windows key, Command key (Apple), or Magnifier key (C\
hromebook).")"
        msg_info "$text"
    elif [[ $title = $(gettext 'Set user photo') ]]; then
        text="$(gettext 'Set user photo'):

$(gettext 'No user photo was found when backing up.')"
        if type xdg-user-dir &> /dev/null; then
            if [[ -f $(xdg-user-dir PICTURES)/$(gettext 'Userphoto') ]]; then
                text="$(gettext 'Set user photo'):

$(gettext "1. Press the Super key[1], type 'user' and click behind Settings on\
 Users.
2. Click the image for the user.
3. Click Select a file.
4. Select Userphoto in Personal folder / Pictures.
5. Close the Users screen.

[1] The Super key is the Windows key, Command key (Apple), or Magnifier key (C\
hromebook).")"
                msg_info "$text"
            else
                msg_info "$text"
            fi
        else
            msg_info "$text"
        fi
    fi
}


# This function processes the command corresponding to the choice made.
function process_commands {
    local       action=''
    local       command=''
    local   -i  row=0

    if [[ ${#rows[@]} -eq 1 ]]; then
        execute_command=true
    else
        show_commands_before_execution
    fi
    if $execute_command; then
        for row in "${!rows[@]}"; do
            action=$(
                printf '%s' "${rows[$row]}" | cut --delimiter='#' --fields=1
                )
            command=$(
                printf '%s' "${rows[$row]}" | cut --delimiter='#' --fields=2
                )
            title=$action
            execute_command
        done
    fi
}


# This function shows the commands before they are executed.
function show_commands_before_execution {
    local       action=''
    local       command=''
    local   -i  row=0
    local       prompt=''

    text="$(gettext 'The following will be executed:')
"
    for row in "${!rows[@]}"; do
        action=$(
            printf '%s' "${rows[$row]}" | cut --delimiter='#' --fields=1
            )
        command=$(
            printf '%s' "${rows[$row]}" | cut --delimiter='#' --fields=2
            )
        text+="
$row. $action"
    done
    text+='
'
    prompt="$(gettext 'Proceed?')"
    if $option_gui; then
        text+="
$prompt"
        if zenity   --question                          \
                    --no-markup                         \
                    --width         600                 \
                    --height        100                 \
                    --title         "$title"            \
                    --text          "$text"             \
                    --ok-label      "$(gettext 'Yes')"  \
                    --cancel-label  "$(gettext 'No')"   2> >($LOGCMD); then
            execute_command=true
        else
            execute_command=false
        fi
    else
        printf '\n%s\n' "$text"
        while true; do
            read -rp "$(eval_gettext "\$prompt [Y/n]: ")"
            case $REPLY in
                [YyJj]*|'')
                    execute_command=true
                    break
                    ;;
                [Nn]*)
                    execute_command=false
                    break
                    ;;
                *)
                    continue
                    ;;
            esac
        done
    fi
}


# This function executes the commands.
function execute_command {
    local   -i  rc=0
    local       cmd=''
    local       row=''
    local       gui_option=''

    # Handle manual actions.
    if [[ $command = $(gettext '"manually"') ]]; then
        manual_actions
        if ! $option_gui; then
            wait_for_enter
        fi
        return $OK
    fi

    # Process (automatic) commands.
    row=${command/kz /kz-}
    cmd=$(
        printf '%s' "$row" | cut --delimiter=' ' --fields=1
        )
    arg=$(
        printf '%s' "$row" | cut --delimiter=' ' --fields=2- --only-delimited
        )
    if $option_gui; then
        gui_option='--gui'
    fi
    "$PROGRAM_PATH/$cmd" "$arg" $gui_option -- || rc=$?
    msg_log "$command: rc=$rc"
}


# This function controls the termination of the script.
function term_script {
    exit $OK
}


###############################################################################
# Main Script
###############################################################################

function main {
    init_script "$@"
    check_input "$@"
    process_input
    term_script
}

main "$@"
