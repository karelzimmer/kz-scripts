#!/usr/bin/bash
# shellcheck source=kz-common.sh
###############################################################################
# Apps instellen.                                                             #
#                                                                             #
# Geschreven door Karel Zimmer <info@karelzimmer.nl>.                         #
###############################################################################

PROGRAM_PATH=$(realpath "$(dirname  "$0")")
readonly PROGRAM_PATH
source  "$PROGRAM_PATH"/kz-common.sh
readonly PROGRAM_NAME='kz-setup'
readonly DISPLAY_NAME=${PROGRAM_NAME/kz-/kz }
readonly RELEASE_YEAR=2013

###############################################################################
# Global constants                                                            #
###############################################################################

readonly OPTIONS_SHORT=$OPTIONS_SHORT_COMMON'ace:fgilrs'
readonly OPTIONS_LONG=$OPTIONS_LONG_COMMON",apps,cat,edition:,files,gui,info,\
list,reset,simulate"
readonly USAGE="Gebruik: $DISPLAY_NAME [-a|--apps] [-c|--cat] \
[-e|--edition=EDITIE] [-f|--files] [-g|--gui]
                  [-i|--info] [-l|--list] [-r|--reset] [-s|--simulate]
                  $OPTIONS_USAGE_COMMON
                  [APP...] [BESTAND...]"
readonly HELP="Gebruik: $DISPLAY_NAME [OPTIE...] [APP...] [BESTAND...]

Apps instellen.

Opties:
  -a, --apps     toon lijst van in te stellen apps
  -c, --cat      toon inhoud van instellingsbestanden
  -e, --edition=EDITIE
                 gebruik opgegeven editie
  -f, --files    toon lijst van beschikbare instellingsbestanden
  -g, --gui      start in grafische modus
  -i, --info     toon aanvullende instructies na het instellen van apps
  -l, --list     maak instellijst aan
  -r, --reset    toon instructies voor het resetten van apps
  -s, --simulate geen actie, simuleer wijzigingen, en toon opdracht die
                 uitgevoerd zou worden
$OPTIONS_HELP_COMMON

Argumenten:
  APP            opgegeven apps instellen
  BESTAND        opgegeven instellingsbestanden verwerken"

DASHES=$(printf '%.0s=' {1..79})
readonly DASHES
readonly EDITION_DEFAULT=desktop
SPACES=$(printf '%.0s ' {1..79})
readonly SPACES
VERSION=$(lsb_release --release --short)
readonly VERSION
CMDS_FILE=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.cmds")
readonly CMDS_FILE
CMDS_FILE2=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.cmds")
readonly CMDS_FILE2
TEXT_FILE=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.text")
readonly TEXT_FILE

###############################################################################
# Global variables                                                            #
###############################################################################

declare -a  APP_ARGUMENT=()
declare     ARGUMENT_APP=false
declare     ARGUMENT_FILE=false
declare     COMMANDS_FOUND=false
declare     EDITION=$EDITION_DEFAULT
declare     EDITION_ARGUMENT=''
declare     EXECUTE_COMMANDS=true
declare -a  FILE_ARGUMENT=()
declare -a  FILE_TO_PROCESS=()
declare     INFO_FOUND=false
declare     LESS_OPTIONS=''
declare -i  MAXRC=0
declare     OPTION_APPS=false
declare     OPTION_CAT=false
declare     OPTION_EDITION=false
declare     OPTION_FILES=false
declare     OPTION_GUI=false
declare     OPTION_INFO=false
declare     OPTION_LIST=false
declare     OPTION_RESET=false
declare     OPTION_SIMULATE=false
declare     RESET_FOUND=false
declare     STATUS_BUSY=''

# Terminalattributen, zie 'man terminfo'.  Gebruik ${<variabele-naam>}.
declare     BLINK=''
declare     CARRIAGE_RETURN=''
declare     CURSOR_INVISABLE=''
declare     CURSOR_VISABLE=''

###############################################################################
# Functions                                                                   #
###############################################################################

function check_input {
    local -i    app_arg_num=0
    local -i    file_arg_num=0
    local -i    getopt_rc=0
    local       parsed=''

    parsed=$(
        getopt  --alternative                       \
                --options       "$OPTIONS_SHORT"    \
                --longoptions   "$OPTIONS_LONG"     \
                --name          "$DISPLAY_NAME"     \
                --              "$@"
        )       || getopt_rc=$?
    if [[ $getopt_rc -ne $SUCCESS ]]; then
        info "$USAGELINE" >&2
        exit $ERROR
    fi
    eval set -- "$parsed"
    process_common_options "$@"
    STATUS_ERROR="[${RED}FOUT${NORMAL}]"
    STATUS_SUCCESS="[${GREEN}GOED${NORMAL}]"

    while true; do
        case $1 in
            -a|--apps)
                OPTION_APPS=true
                shift
                ;;
            -c|--cat)
                OPTION_CAT=true
                shift
                ;;
            -e|--edition)
                if $OPTION_EDITION; then
                    error "Optie '$1' eenmaal opgeven."
                    info "$USAGELINE" >&2
                    exit $ERROR
                else
                    OPTION_EDITION=true
                    EDITION_ARGUMENT=$2
                    EDITION=$EDITION_ARGUMENT
                fi
                shift 2
                ;;
            -f|--files)
                OPTION_FILES=true
                shift
                ;;
            -g|--gui)
                OPTION_GUI=true
                if [[ -t 1 ]]; then
                    reset_terminal_attribs
                fi
                shift
                ;;
            -i|--info)
                OPTION_INFO=true
                EXECUTE_COMMANDS=false
                shift
                ;;
            -l|--list)
                OPTION_LIST=true
                EXECUTE_COMMANDS=false
                shift
                ;;
            -r|--reset)
                OPTION_RESET=true
                EXECUTE_COMMANDS=false
                shift
                ;;
            -s|--simulate)
                OPTION_SIMULATE=true
                EXECUTE_COMMANDS=false
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                shift
                ;;
        esac
    done

    # Verwerk argumenten.
    while [[ "$*" ]]; do
        if [[ "$(basename "$1")" == $PROGRAM_NAME-*.sh ]]; then
            ARGUMENT_FILE=true
            FILE_ARGUMENT[$file_arg_num]=$1
            ((++file_arg_num))
            shift
        else
            ARGUMENT_APP=true
            APP_ARGUMENT[$app_arg_num]=$1
            ((++app_arg_num))
            shift
        fi
    done

    if [[ -t 1 ]]; then
        BLINK=$(tput blink)
        CARRIAGE_RETURN=$(tput cr)
        CURSOR_INVISABLE=$(tput civis)
        CURSOR_VISABLE=$(tput cvvis)
    fi
}

function less_options {
    # Less-opties, overgenomen (en aangepast, zie 'man less', zoek PROMPTS)
    # van:
    # 1. systemctl en journalctl, zie bijv. 'man systemctl', zoek LESS
    #    ("FRSXMK")
    # 2. man, zie 'man man', zoek LESS
    LESS_OPTIONS="--LONG-PROMPT --no-init --quit-if-one-screen --quit-on-intr \
--RAW-CONTROL-CHARS --prompt=M$1 ?ltregel %lt?L van %L.:byte %bB?s van %s..? \
.?e (EINDE) :?pB %pB\%. .(druk h voor hulp of q voor stoppen)"
}

function process_input {
    local -i    app_seq_num=0
    local -i    app_tot_num=0
    local       dfltfile_1=''
    local       dfltfile_2=''
    local       file_notfound=false
    local -i    file_num=0
    local       file=''
    local       skip_line=false

    dfltfile_1=$PROGRAM_PATH/$PROGRAM_NAME-$DISTRO-$VERSION-$EDITION.sh
    dfltfile_2=$PROGRAM_PATH/$PROGRAM_NAME-$DISTRO-$VERSION-$EDITION-\
$HOSTNAME.sh
    if $OPTION_LIST; then
        check_user
        process_option_list
        exit $SUCCESS
    fi
    if $ARGUMENT_APP; then
        process_argument_app
    fi
    if $ARGUMENT_FILE; then
        process_argument_file
    fi

    # Als argument APP of FILE is opgegeven, geen standaardbestanden verwerken.
    if ! ($ARGUMENT_APP || $ARGUMENT_FILE); then
        process_dfltfiles
    fi

    # Verwerk opties.
    if $OPTION_APPS; then
        process_option_apps
        exit $SUCCESS
    elif $OPTION_FILES; then
        process_option_files
        exit $SUCCESS
    fi

    # Ergens hiervoor ging het niet helemaal goed.
    if $file_notfound; then
        exit $SUCCESS
    fi

    # Optie cat is afhankelijk van argumenten APP en FILE.
    if $OPTION_CAT; then
        process_option_cat
        exit $SUCCESS
    fi

    # We gaan opdrachten uitvoeren, mogen we dat wel?
    if $EXECUTE_COMMANDS; then
        check_user
    fi

    # We gaan opdrachten uitvoeren of simuleren.
    for file in "${FILE_TO_PROCESS[@]}"; do
        cat "$file" >> "$CMDS_FILE"
    done

    # 'if ! grep --regexp='^#2'...; then...' werkt niet; grep geeft 0
    # terug als niets gevonden, is OK, maar dan ook rc=1, is niet OK.
    app_tot_num=$(
        grep --word-regexp --regexp='^#1' --count "$CMDS_FILE" || true
        )

    if $EXECUTE_COMMANDS && $OPTION_GUI; then
        TITLE='Apps instellen'
        TEXT=''
        # Met "|& zenity --progress" worden globale variabelen uit
        # aangeroepen functies niet doorgegeven, vandaar de
        # 'process substitution' met "> >(zenity...)".
        process_file > >(
            zenity  --progress              \
                    --pulsate               \
                    --auto-close            \
                    --no-cancel             \
                    --width     700         \
                    --height    50          \
                    --title     "$TITLE"    \
                    --text      "$TEXT"     2> >($LOGCMD)
            )
    else
        process_file
    fi
}

function process_option_list {
    if [[ -f "${XDG_CONFIG_HOME:-~/.config}"/user-dirs.dirs ]]; then
        source "${XDG_CONFIG_HOME:-~/.config}"/user-dirs.dirs
    fi
    local docs_dir=${XDG_DOCUMENTS_DIR:-$HOME/Documenten}/kz
    local text0='Opdrachten worden verwerkt'
    local text1='[1/4]  Gebruikersfoto vastleggen'
    local file1="$docs_dir/Gebruikersfoto"
    local text2='[2/4]  Bureaubladachtergrond vastleggen'
    local file2="$docs_dir/Bureaubladachtergrond"
    local text3='[3/4]  Favorieten vastleggen'
    local file3="$docs_dir/Favorieten"
    local text4='[4/4]  Opdrachtgeschiedenis vastleggen'
    local file4="$docs_dir/Opdrachtgeschiedenis"

    mkdir --parents "$docs_dir"

    TITLE='Instellijst maken'
    if $OPTION_GUI; then
        (
        printf '%s\n' "#$text1"
        save_user_photo
        printf '%s\n' "#$text2"
        save_desktop_background
        printf '%s\n' "#$text3"
        save_favorite_apps
        printf '%s\n' "#$text4"
        save_command_history
        ) |&
        zenity  --progress              \
                --pulsate               \
                --auto-close            \
                --no-cancel             \
                --width     600         \
                --height    50          \
                --title     "$TITLE"    \
                --text      "$text0"    2> >($LOGCMD)
    else
        save_user_photo
        save_desktop_background
        save_favorite_apps
        save_command_history
    fi

    info "
De instellingen zijn vastgelegd in de map kz in Documenten.
In map kz de bestanden met de eerder gebruikte Gebruikersfoto,
Bureaubladachtergrond, Favorieten, en Opdrachtgeschiedenis.
Deze bestanden kunnen worden gebruikt voor het nalopen van het instellen."
}

function save_user_photo {
    printf '%s\n' "$text1..."
    if ! cp /var/lib/AccountsService/icons/"$USER" "$file1" |& $LOGCMD; then
        rm --force "$file1"
        touch "$file1"
    fi
}

function save_desktop_background {
    printf '%s\n' "$text2..."
    gsettings get   org.gnome.desktop.background    \
                    picture-uri                     > "$file2" |& $LOGCMD
}

function save_favorite_apps {
    printf '%s\n' "$text3..."
    gsettings get   org.gnome.shell \
                    favorite-apps   > "$file3" |& $LOGCMD
}

function save_command_history {
    printf '%s\n' "$text4..."
    HISTFILE=~/.bash_history
    set -o history
    history > "$file4" |& $LOGCMD
}

function process_argument_app {
    local       app=''
    local       file=''
    local -a    file_to_process=()

    # Niet verplicht aanwezig.
    if [[ -e $dfltfile_1 ]]; then
        file_to_process[0]=$dfltfile_1
    fi
    # Verplicht aanwezig.
    if [[ -e $dfltfile_2 ]]; then
        file_to_process[1]=$dfltfile_2
    else
        info "Geen installatiebestanden gevonden voor $DISTRO $VERSION \
$EDITION."
        exit $WARNING
    fi

    # Install zoekt naar apps in alle kz-install-<distro>-<versie>-bestanden
    # en stopt bij de eerstgevonden (installatie is computer-onafhankelijk),
    # setup zoekt naar apps in kz-install-<distro>-<versie>-<edition>.sh en
    # kz-install-<distro>-<versie>-<edition>-<computernaam>.sh.
    for app in "${APP_ARGUMENT[@]}"; do
        if ! grep   --files-with-matches    \
                    --word-regexp           \
                    --regexp="#1 $app"      \
                    "${file_to_process[@]}" \
                    &> /dev/null; then
            warning "App '$app' niet gevonden."
            file_notfound=true
        else
            process_argument_app_file
        fi
    done
    if $file_notfound; then
        info "Typ '$DISPLAY_NAME --apps' voor beschikbare apps." >&2
    else
        FILE_TO_PROCESS[$file_num]=$CMDS_FILE2
        ((++file_num))
    fi
}

function process_argument_app_file {
    local app_found=false
    local record=''
    local temp_file=''

    temp_file=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.temp")
    cat "${file_to_process[@]}" > "$temp_file"

    while read -r record; do
        case $record in
            '#1 '*)
                if [[ $record == '#1 '$app* ]]; then
                    # Gezochte app-naam.
                    # Regels doorschrijven naar tijdelijk bestand tot
                    # eerstvolgende app-naam of tot eof.
                    app_found=true
                    printf '%b\n' "$record" >> "$CMDS_FILE2"
                elif $app_found; then
                    # Volgende app-naam.
                    break
                fi
                ;;
            *)
                # Overige regels.
                if $app_found; then
                    printf '%s\n' "$record" >> "$CMDS_FILE2"
                fi
                ;;
        esac
    done < "$temp_file"

    rm "$temp_file" |& $LOGCMD
}

function process_argument_file {
    local file=''

    for file in "${FILE_ARGUMENT[@]}"; do
        if [[ -e $file ]]; then
            FILE_TO_PROCESS[$file_num]=$file
            ((++file_num))
        else
            warning "Bestand $file niet gevonden."
            file_notfound=true
        fi
    done
    if $file_notfound; then
        info "Typ '$DISPLAY_NAME --files' voor beschikbare \
instellingsbestanden." >&2
    fi
}

function process_dfltfiles {
    # Verplicht aanwezig.
    if [[ -e $dfltfile_1 ]]; then
        FILE_TO_PROCESS[$file_num]=$dfltfile_1
        ((++file_num))
    else
        warning "Geen installatiebestanden gevonden voor $DISTRO $VERSION \
$EDITION." >&2
        exit $WARNING
    fi
    # Niet verplicht aanwezig.
    if [[ -e $dfltfile_2 ]]; then
        FILE_TO_PROCESS[$file_num]=$dfltfile_2
        ((++file_num))
    fi
}

function process_option_apps {
    # Install zoekt naar apps in alle kz-install-<distro>-<versie>-bestanden
    # en stopt bij de eerstgevonden (installatie is computer-onafhankelijk),
    # setup zoekt naar apps in kz-install-<distro>-<versie>-<edition>.sh en
    # kz-install-<distro>-<versie>-<edition>-<computernaam>.sh.
    process_dfltfiles
    TEXT="De volgende apps zijn beschikbaar:

NUMMER APP (BESCHRIJVING)
$(
    if !    grep    --no-messages           \
                    --regexp='^#1 '         \
                    "${FILE_TO_PROCESS[@]}" |
            cut     --delimiter=' '         \
                    --fields=2-             |
            sort    --unique                |
            nl      --number-width=6        \
                    --number-format=rn      \
                    --number-separator=' '  \
                    --body-numbering=a; then
        printf '%s\n' "     0 Geen apps gevonden voor $DISTRO $VERSION."
    else
        printf '%s\n' "
Om APPs te bekijken voer uit:
    ${BLUE}$DISPLAY_NAME --sim APP...${NORMAL}
    ${BLUE}$DISPLAY_NAME --cat APP...${NORMAL}
Om APPs in te stellen voer uit:
    ${BLUE}$DISPLAY_NAME APP...${NORMAL}"
    fi
)"
    info "$TEXT"
}

function process_option_files {
    TEXT="De volgende instellingsbestanden zijn beschikbaar:

NUMMER BESTAND
$(
    if !    find    "${FILE_TO_PROCESS[@]}" \
                    2> /dev/null            |
            nl      --number-width=6        \
                    --number-format=rn      \
                    --number-separator=' '  \
                    --body-numbering=a; then
        printf '%s\n' "     0 Geen instellingsbestanden gevonden voor $DISTRO \
$VERSION $EDITION.

Typ 'man $DISPLAY_NAME' voor meer informatie."
    else
        printf '%s\n' "
Om BESTANDen te bekijken voer uit:
    ${BLUE}$DISPLAY_NAME --sim BESTAND...${NORMAL}
    ${BLUE}$DISPLAY_NAME --cat BESTAND...${NORMAL}
Om BESTANDen te gebruiken voer uit:
    ${BLUE}$DISPLAY_NAME BESTAND...${NORMAL}"
    fi
)"
    info "$TEXT"
}

function process_option_cat {
    local first_file=true

    for file in "${FILE_TO_PROCESS[@]}"; do
        {
            if $first_file; then
                first_file=false
            else
                printf '\n'
            fi
            printf '%s\n' "${BLUE}# $file${NORMAL}"
            cat "$file"
        }   >> "$CMDS_FILE"
    done
    TITLE='Instellings-bestanden'
    if $OPTION_GUI; then
        if ! zenity --text-info                         \
                    --width         850                 \
                    --height        400                 \
                    --title         "$TITLE"            \
                    --filename      "$CMDS_FILE"        \
                    --font          'Ubuntu Mono 12'    \
                    --checkbox      'Gezien'            \
                    --ok-label      'Oké'               \
                    --cancel-label  'Afsluiten'         2> >($LOGCMD); then
            true
        fi
    else
        less_options "$TITLE"
        less "$LESS_OPTIONS" "$CMDS_FILE"
    fi
}

function process_file {
    local       app_description=''
    local -i    cmd_seq_num=0
    local       first_description_line=true
    local       first_reset_instruction=true
    local       first_setup_instruction=true
    local       prev_recordtype=''
    local       record=''
    local       recordtype=''
    local       write_app_description_line=true

    if $EXECUTE_COMMANDS; then
        STATUS_BUSY="[${BLINK}${BOLD}WERK${NORMAL}]"
        printf '%b' "${CURSOR_INVISABLE}"
    fi
    $skip_line && printf '\n'; skip_line=true

    while read -r record; do
        recordtype=${record:0:2}
        case $recordtype in
            '')
                # Lege regel of lege app-naam.
                continue
                ;;
            '#1')
                process_app_description "$record"
                ;;
            '#2')
                process_setup_instruction "$record"
                ;;
            '#3')
                process_reset_instruction "$record"
                ;;
            '#'*)
                # Commentaarregel.
                continue
                ;;
            *)
                process_command "$record"
                ;;
        esac
        prev_recordtype=$recordtype
    done < "$CMDS_FILE"

    if $EXECUTE_COMMANDS; then
        printf '%b' "${CURSOR_VISABLE}"
    fi
}

function process_app_description {
    local record=${1:-record?}

    app_description="${record:3}"
    if ! $OPTION_SIMULATE && ! $EXECUTE_COMMANDS; then
        return $SUCCESS
    fi

    write_app_description_line=true
    ((++app_seq_num))
    cmd_seq_num=0
}

function process_setup_instruction {
    local       record=${1:-record?}
    local       filler=''
    local -i    len=0

    INFO_FOUND=true
    if ! $OPTION_INFO; then
        return $SUCCESS
    fi
    filler=${SPACES:0:8}
    if [[ $prev_recordtype = '#2' ]]; then
        printf '%s%s\n' "$filler" "${record:3}" >> "$TEXT_FILE"
    else
        ((++app_seq_num))
        if $first_setup_instruction; then
            first_setup_instruction=false
        else
            printf '\n' >> "$TEXT_FILE"
        fi
        len=${#app_description}
        # ?? wordt in term_script vervangen door aantal in te stellen apps.
        printf  "[%2d/??] %s\n%s%.${len}s\n%s%s\n"  \
                "$app_seq_num"  "$app_description"  \
                "$filler"       "$DASHES"           \
                "$filler"       "${record:3}"       >> "$TEXT_FILE"
    fi
}

function process_reset_instruction {
    local       record=${1:-record?}
    local       filler=''
    local -i    len=0

    RESET_FOUND=true
    if ! $OPTION_RESET; then
        return $SUCCESS
    fi
    filler=${SPACES:0:8}
    if [[ $prev_recordtype = '#3' ]]; then
        printf '%s%s\n' "$filler" "${record:3}" >> "$TEXT_FILE"
    else
        ((++app_seq_num))
        if $first_reset_instruction; then
            first_reset_instruction=false
        else
            printf '\n' >> "$TEXT_FILE"
        fi
        len=${#app_description}
        # ?? wordt in term_script vervangen door aantal te resetten apps.
        printf  "[%2d/??] %s\n%s%.${len}s\n%s%s\n"  \
                "$app_seq_num"  "$app_description"  \
                "$filler"       "$DASHES"           \
                "$filler"       "${record:3}"       >> "$TEXT_FILE"
    fi
}

function process_command {
    local       record=${1:-record?}
    local       app_description_line=''
    local -i    cmd_rc=0
    local -i    desc_maxlen=1000
    local       desc_printf=''
    local       status=''

    COMMANDS_FOUND=true
    ((++cmd_seq_num))

    if $OPTION_SIMULATE; then
        if $write_app_description_line; then
            if $first_description_line; then
                first_description_line=false
            else
                printf '\n' >> "$TEXT_FILE"
            fi
            printf  '[%3d/%-3d] %s\n'   \
                    "$app_seq_num"      \
                    "$app_tot_num"      \
                    "$app_description"  >> "$TEXT_FILE"
            write_app_description_line=false
        fi
        printf  '%9s [%2d] %s\n'            \
                " "                         \
                "$cmd_seq_num"              \
                "${BLUE}$record${NORMAL}"   >> "$TEXT_FILE"
    elif $EXECUTE_COMMANDS; then
        desc_printf=$app_description
        if $OPTION_GUI; then
            TEXT="#[$app_seq_num/$app_tot_num] $app_description...\n\n$record"
            printf '%s\n' "$TEXT"
        else
            if [[ -t 1 ]]; then
                # Afbreken in Terminalvenster moet i.v.m. updaten status.
                #  <------------- tput cols ------------->
                # '[WERK] [  1/1  ] [ 1] Te lange descr...' <=== op 1 regel
                #  <-------- 22 -------->
                desc_maxlen=$(($(tput cols) - 22))
                if [[ ${#desc_printf} -gt $desc_maxlen ]]; then
                    desc_printf=${desc_printf:0:(($desc_maxlen - 3))}'...'
                fi
            fi
        fi
        printf  -v app_description_line                             \
                "[%3d/%-3d] [%2d] %-${desc_maxlen}.${desc_maxlen}s" \
                "$app_seq_num"                                      \
                "$app_tot_num"                                      \
                "$cmd_seq_num"                                      \
                "$desc_printf"
        execute_command "$record"
    fi
}

function execute_command {
    local       cmd=${1:-cmd?}
    local -i    cmd_rc=0
    local       filler=''
    local       status=''

    if ! $OPTION_GUI; then
        if [[ $cmd_seq_num -eq 1 ]]; then
            printf "$STATUS_BUSY %s${CARRIAGE_RETURN}" "$app_description_line"
        else
            printf  "$STATUS_BUSY ${SPACES:0:9}%s${CARRIAGE_RETURN}" \
                    "${app_description_line:9}"
        fi
    fi

    log "$app_description_line"
    log "${BLUE}$cmd${NORMAL}"
    eval "$cmd" |& $LOGCMD || cmd_rc=$?
    if [[ $cmd_rc -gt $MAXRC ]]; then
        MAXRC=$cmd_rc
    fi
    if [[ $cmd_rc -eq $SUCCESS ]]; then
        status="$STATUS_SUCCESS"
    else
        status="$STATUS_ERROR"
    fi
    log "$status rc=$cmd_rc, maxrc=$MAXRC"
    printf '%s\n' "$status"
}

function term_script {
    local -i app_num=0

    if $OPTION_SIMULATE; then
        TITLE='Instellings-opdrachten'
        if $OPTION_GUI; then
            if ! zenity --text-info                         \
                        --width         1000                \
                        --height        400                 \
                        --title         "$TITLE"            \
                        --filename      "$TEXT_FILE"        \
                        --font          'Ubuntu Mono 12'    \
                        --checkbox      'Gezien'            \
                        --ok-label      'Oké'               \
                        --cancel-label  'Afsluiten'         2> >($LOGCMD); then
                true
            fi
        else
            less_options "$TITLE"
            less "$LESS_OPTIONS" "$TEXT_FILE"
        fi
    elif $OPTION_INFO && $INFO_FOUND; then
        # Vervang ?? door aantal in te stellen apps.
        app_num=$(grep --regexp='\??] ' --count "$TEXT_FILE")
        sed -i "s|/??] |/$(printf %-2d "$app_num")] |g" "$TEXT_FILE"
        TITLE='Instel-instructies'
        if $OPTION_GUI; then
            if ! zenity --text-info                         \
                        --width         850                 \
                        --height        400                 \
                        --title         "$TITLE"            \
                        --filename      "$TEXT_FILE"        \
                        --font          'Ubuntu Mono 12'    \
                        --checkbox      'Gezien'            \
                        --ok-label      'Oké'               \
                        --cancel-label  'Afsluiten'         2> >($LOGCMD); then
                true
            fi
        else
            less_options "$TITLE"
            less "$LESS_OPTIONS" "$TEXT_FILE"
        fi
    elif $OPTION_INFO && ! $INFO_FOUND; then
        info 'Geen instel-instructies.'
    elif $OPTION_RESET && $RESET_FOUND; then
        # Vervang ?? door aantal te resetten apps.
        app_num=$(grep --regexp='\??] ' --count "$TEXT_FILE")
        sed -i "s|/??] |/$(printf %-2d "$app_num")] |g" "$TEXT_FILE"
        TITLE='Reset-instructies'
        if $OPTION_GUI; then
            if ! zenity --text-info                         \
                        --width         850                 \
                        --height        400                 \
                        --title         "$TITLE"            \
                        --filename      "$TEXT_FILE"        \
                        --font          'Ubuntu Mono 12'    \
                        --checkbox      'Gezien'            \
                        --ok-label      'Oké'               \
                        --cancel-label  'Afsluiten'         2> >($LOGCMD); then
                true
            fi
        else
            less_options "$TITLE"
            less "$LESS_OPTIONS" "$TEXT_FILE"
        fi
    elif $OPTION_RESET && ! $RESET_FOUND; then
        info 'Geen reset-instructies.'
    elif ! $COMMANDS_FOUND; then
        info 'Geen opdrachten.'
    fi

    if  $EXECUTE_COMMANDS && $INFO_FOUND && ! $OPTION_GUI; then
        info "
Er zijn aanvullende instructies.

Gebruik de opdracht:
    ${BLUE}$DISPLAY_NAME --info ${APP_ARGUMENT[*]}${NORMAL}"
    fi

    if $EXECUTE_COMMANDS; then
        if [[ $MAXRC -ne $SUCCESS ]]; then
            warning "
Instellen is geëindigd met een waarschuwing.

Controleer de log in het Terminalvenster met:
    ${BLUE}$LOGCMD_CHECK${NORMAL}"
            exit $WARNING
        else
            info '
Instellen is voltooid.'
            exit $SUCCESS
        fi
    fi
}

###############################################################################
# Main line                                                                   #
###############################################################################

function main {
    init_script "$@"
    check_input "$@"
    process_input
    term_script
}

main "$@"
