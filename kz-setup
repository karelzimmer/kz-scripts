#!/bin/bash
# shellcheck source=kz-common.sh
###############################################################################
# Apps instellen.
#
# Geschreven door Karel Zimmer <info@karelzimmer.nl>.
###############################################################################

PROGRAM_PATH=$(realpath "$(dirname  "$0")")
readonly PROGRAM_PATH
source  "$PROGRAM_PATH"/kz-common.sh
readonly PROGRAM_NAME='kz-setup'
readonly DISPLAY_NAME=${PROGRAM_NAME/kz-/kz }
readonly RELEASE_YEAR=2013


###############################################################################
# Global constants
###############################################################################

readonly OPTIONS_SHORT=$OPTIONS_SHORT_COMMON'ace:fglrs'
readonly OPTIONS_LONG=$OPTIONS_LONG_COMMON",apps,cat,edition:,files,gui,list,\
reset,simulate"
readonly USAGE="Gebruik: $DISPLAY_NAME [-a|--apps] [-c|--cat] \
[-e|--edition=EDITIE] [-f|--files]
                  [-g|--gui] [-l|--list] [-r|--reset] [-s|--simulate]
                  $OPTIONS_USAGE_COMMON
                  [APP...] [BESTAND...]"
readonly HELP="Gebruik: $DISPLAY_NAME [OPTIE...] [APP...] [BESTAND...]

Apps instellen.

Opties:
  -a, --apps     toon lijst van beschikbare apps
  -c, --cat      toon inhoud van bestanden
  -e, --edition=EDITIE
                 gebruik opgegeven EDITIE
  -f, --files    toon lijst van bestanden
  -g, --gui      start in grafische modus
  -l, --list     maak instellijst aan
  -r, --reset    reset apps
  -s, --simulate toon opdrachten
$OPTIONS_HELP_COMMON

Argumenten:
  APP            opgegeven APPs instellen
  BESTAND        opgegeven BESTANDen verwerken"

DISTRO=$(lsb_release --id --short | tr '[:upper:]' '[:lower:]')
readonly DISTRO
readonly EDITION_DEFAULT=desktop
VERSION=$(lsb_release --release --short)
readonly VERSION

APPS_FILE=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.apps")
readonly APPS_FILE
CMDS_FILE=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.cmds")
readonly CMDS_FILE
SIM_FILE=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.sim")
readonly SIM_FILE


###############################################################################
# Global variables
###############################################################################

declare -a  APP_ARGUMENTS=()
declare     ARGUMENT_APP=false
declare     ARGUMENT_FILE=false
declare     COMMANDS_FOUND=false
declare     EDITION=$EDITION_DEFAULT
declare     EXECUTE_COMMANDS=true
declare -a  FILE_ARGUMENTS=()
declare -a  FILES_TO_PROCESS=()
declare -i  MAXRC=0
declare     OPTION_APPS=false
declare     OPTION_CAT=false
declare     OPTION_FILES=false
declare     OPTION_GUI=false
declare     OPTION_LIST=false
declare     OPTION_RESET=false
declare     OPTION_SIMULATE=false
declare     STATUS_BUSY=''
declare     STATUS_ERROR=''
declare     STATUS_SUCCESS=''


###############################################################################
# Functions
###############################################################################

function check_input {
    local -i    app_arg_num=0
    local -i    file_arg_num=0
    local -i    getopt_rc=0
    local       parsed=''

    parsed=$(
        getopt  --alternative                       \
                --options       "$OPTIONS_SHORT"    \
                --longoptions   "$OPTIONS_LONG"     \
                --name          "$DISPLAY_NAME"     \
                --              "$@"
        )       || getopt_rc=$?
    if [[ $getopt_rc -ne $SUCCESS ]]; then
        process_usage
        NOERROR=true exit $ERROR
    fi
    eval set -- "$parsed"
    process_common_options "$@"

    while true; do
        case $1 in
            -a|--apps)
                OPTION_APPS=true
                shift
                ;;
            -c|--cat)
                OPTION_CAT=true
                shift
                ;;
            -e|--edition)
                EDITION=$2
                shift 2
                ;;
            -f|--files)
                OPTION_FILES=true
                shift
                ;;
            -g|--gui)
                OPTION_GUI=true
                reset_terminal_attributes
                shift
                ;;
            -l|--list)
                OPTION_LIST=true
                shift
                ;;
            -r|--reset)
                OPTION_RESET=true
                shift
                ;;
            -s|--simulate)
                OPTION_SIMULATE=true
                EXECUTE_COMMANDS=false
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                shift
                ;;
        esac
    done

    # Verwerk argumenten.
    while [[ "$*" ]]; do
        if [[ "$(basename "$1")" == $PROGRAM_NAME-*.sh ]]; then
            ARGUMENT_FILE=true
            FILE_ARGUMENTS[$file_arg_num]=$1
            ((++file_arg_num))
            shift
        else
            ARGUMENT_APP=true
            APP_ARGUMENTS[$app_arg_num]=$1
            ((++app_arg_num))
            shift
        fi
    done
}


function process_input {
    local       dfltfile_1=''
    local       dfltfile_2=''
    local       file_notfound=false
    local -i    file_num=0
    local       file=''

    # Verwerk optie list.
    if $OPTION_LIST; then
        check_user_root
        process_option_list
        exit $SUCCESS
    fi

    # Verwerk argumenten.
    dfltfile_1=$PROGRAM_PATH/$PROGRAM_NAME-$DISTRO-$VERSION-$EDITION.sh
    dfltfile_2=$PROGRAM_PATH/$PROGRAM_NAME-$DISTRO-$VERSION-$EDITION\
-$HOSTNAME-$USER.sh
    if $ARGUMENT_APP; then
        process_argument_app
    fi
    if $ARGUMENT_FILE; then
        process_argument_file
    fi
    # Ergens hiervoor ging het niet helemaal goed.
    if $file_notfound; then
        NOERROR=true exit $ERROR
    fi
    # Voor bepaalde argumenten en opties geen standaardbestanden verwerken.
    if ! ($ARGUMENT_APP || $ARGUMENT_FILE || $OPTION_FILES); then
        process_dfltfiles
    fi

    # Verwerk overige opties; afhankelijk van bestanden en argumenten.
    if $OPTION_APPS; then
        process_option_apps
        exit $SUCCESS
    elif $OPTION_CAT; then
        process_option_cat
        exit $SUCCESS
    elif $OPTION_FILES; then
        process_option_files
        exit $SUCCESS
    fi

    # Opdrachten uitvoeren of simuleren.
    if $EXECUTE_COMMANDS; then
        check_user_root
    fi

    for file in "${FILES_TO_PROCESS[@]}"; do
        cat "$file" >> "$CMDS_FILE"
    done

    if $EXECUTE_COMMANDS && $OPTION_GUI; then
        TITLE='Apps instellen'
        TEXT=''
        # Met "|& zenity --progress" worden globale variabelen uit aangeroepen
        # functies niet doorgegeven, vandaar de 'process substitution' met
        # "> >(zenity...)".
        process_cmds_file > >(
            zenity  --progress              \
                    --pulsate               \
                    --auto-close            \
                    --no-cancel             \
                    --width     700         \
                    --height    50          \
                    --title     "$TITLE"    \
                    --text      "$TEXT"     2> >($LOGCMD)
            )
    else
        process_cmds_file
    fi
}


function process_argument_app {
    local       app=''
    local       file=''
    local -a    files=()
    local       temp_file=''

    # Verplicht aanwezig.
    if [[ -e $dfltfile_1 ]]; then
        files[0]=$dfltfile_1
    else
        info "Geen bestanden gevonden voor $DISTRO $VERSION $EDITION."
        NOERROR=true exit $ERROR
    fi
    # Niet verplicht aanwezig.
    if [[ -e $dfltfile_2 ]]; then
        files[1]=$dfltfile_2
    fi

    # kz-install zoekt naar apps in ALLE kz-install-<distro>-<versie>-bestanden
    # en stopt bij de eerstgevonden, kz-setup zoekt naar apps ALLEEN in de
    # staandaard bestanden kz-setup-<distro>-<versie>-<editie>.sh en
    # kz-install-<distro>-<versie>-<editie>-<computernaam>.sh.
    temp_file=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.temp")
    cat "${files[@]}" > "$temp_file"
    for app in "${APP_ARGUMENTS[@]}"; do
        if ! grep   --files-with-matches    \
                    --word-regexp           \
                    --regexp="#1 $app"      \
                    "${files[@]}"           \
                    &> /dev/null; then
            info "App '$app' niet gevonden."
            file_notfound=true
        else
            process_argument_app_file
        fi
    done
    rm "$temp_file" |& $LOGCMD
    if $file_notfound; then
        info "Typ '$DISPLAY_NAME --apps' voor beschikbare apps." >&2
    else
        FILES_TO_PROCESS[$file_num]=$APPS_FILE
        ((++file_num))
    fi
}


function process_argument_app_file {
    local app_found=false
    local record=''

    while read -r record; do
        case $record in
            '#1 '*)
                if [[ $record == '#1 '$app* ]]; then
                    # Gezochte app-naam.
                    # Regels doorschrijven naar tijdelijk bestand tot
                    # eerstvolgende app-naam of tot eof.
                    app_found=true
                    printf '%b\n' "$record" >> "$APPS_FILE"
                elif $app_found; then
                    # Volgende app.
                    app_found=false
                    continue
                fi
                ;;
            '#1-'*)
                if $app_found; then
                    # Volgende (hidden) app.
                    break
                fi
                ;;
            *)
                # Overige regels.
                if $app_found; then
                    printf '%s\n' "$record" >> "$APPS_FILE"
                fi
                ;;
        esac
    done < "$temp_file"
}


function process_argument_file {
    local file=''

    for file in "${FILE_ARGUMENTS[@]}"; do
        if [[ -e $file ]]; then
            FILES_TO_PROCESS[$file_num]=$file
            ((++file_num))
        else
            info "Bestand $file niet gevonden."
            file_notfound=true
        fi
    done
    if $file_notfound; then
        info "Typ '$DISPLAY_NAME --files' voor bestanden op dit systeem." >&2
    fi
}


function process_dfltfiles {
    # Verplicht aanwezig.
    if [[ -e $dfltfile_1 ]]; then
        FILES_TO_PROCESS[$file_num]=$dfltfile_1
        ((++file_num))
    else
        error "Geen bestanden gevonden voor $DISTRO $VERSION $EDITION." >&2
        process_usage
        NOERROR=true exit $ERROR
    fi
    # Niet verplicht aanwezig.
    if [[ -e $dfltfile_2 ]]; then
        FILES_TO_PROCESS[$file_num]=$dfltfile_2
        ((++file_num))
    fi
}


function process_option_apps {
    # kz-install zoekt naar apps in ALLE kz-install-<distro>-<versie>-bestanden
    # en stopt bij de eerstgevonden, kz-setup zoekt naar apps ALLEEN in de
    # staandaard bestanden kz-setup-<distro>-<versie>-<editie>.sh en
    # kz-install-<distro>-<versie>-<editie>-<computernaam>.sh.
    process_dfltfiles
    TEXT="De volgende APPs zijn beschikbaar:

     APP (BESCHRIJVING)
$(
    if !    grep    --no-messages               \
                    --regexp='^#1 '             \
                    "${FILES_TO_PROCESS[@]}"    |
            cut     --delimiter=' '             \
                    --fields=2-                 |
            sort    --unique                    |
            nl      --number-width=2            \
                    --number-format=rn          \
                    --number-separator='] '     \
                    --body-numbering=a          |
            sed     --expression='s/^/[/'; then
        printf '%s\n' "     0 Geen apps gevonden voor $DISTRO $VERSION."
    else
        printf '%s\n' "
Om de inhoud van APPs te bekijken voer uit:      ${BLUE}$DISPLAY_NAME \
--cat APP...${NORMAL}
Om de verwerking van APPs te simuleren voer uit: ${BLUE}$DISPLAY_NAME \
--simulate APP...${NORMAL}
Om de APPs in te stellen voer uit:               ${BLUE}$DISPLAY_NAME \
APP...${NORMAL}"
    fi
)"
    info "$TEXT"
}


function process_option_cat {
    local first_file=true

    for file in "${FILES_TO_PROCESS[@]}"; do
        {
            if $first_file; then
                first_file=false
            else
                printf '\n'
            fi
            printf '%s\n' "${BLUE}# $file${NORMAL}"
            cat "$file"
        }   >> "$CMDS_FILE"
    done
    less "$LESS_OPTIONS" "$CMDS_FILE"
}


function process_option_files {
    TEXT="De volgende BESTANDen staan op het systeem:

     BESTAND
$(
    if !    find    "$PROGRAM_PATH/$PROGRAM_NAME-"* \
                    2> /dev/null                    |
            nl      --number-width=2                \
                    --number-format=rn              \
                    --number-separator='] '         \
                    --body-numbering=a              |
            sed     --expression='s/^/[/'; then
        printf '%s\n' "     0 Geen bestanden aanwezig op het systeem.

$USAGELINE"
    else
        printf '%s\n' "
Om de inhoud van BESTANDen te bekijken voer uit:      ${BLUE}$DISPLAY_NAME \
--cat BESTAND...${NORMAL}
Om de verwerking van BESTANDen te simuleren voer uit: ${BLUE}$DISPLAY_NAME \
--simulate BESTAND...${NORMAL}
Om de BESTANDen te verwerken voer uit:                ${BLUE}$DISPLAY_NAME \
BESTAND...${NORMAL}"
    fi
)"
    info "$TEXT"
}


function process_option_list {
    local tgtdir=$HOME/kz-data
    local text0='Opdrachten worden verwerkt'
    local text1='[1/3] Achtergrond vastleggen'
    local file1="$tgtdir"/Achtergrond
    local text2='[2/3] Gebruikersfoto vastleggen'
    local file2="$tgtdir"/Gebruikersfoto
    local text3='[3/3] Favorieten vastleggen'
    local file3="$tgtdir"/Favorieten

    mkdir --parents "$tgtdir" |& $LOGCMD

    TITLE='Instellijst maken'
    if $OPTION_GUI; then
        (
        printf '%s\n' "#$text1"
        process_option_list_desktop_background
        printf '%s\n' "#$text2"
        process_option_list_user_photo
        printf '%s\n' "#$text3"
        process_option_list_favorite_apps
        ) |&
        zenity  --progress              \
                --pulsate               \
                --auto-close            \
                --no-cancel             \
                --width     600         \
                --height    50          \
                --title     "$TITLE"    \
                --text      "$text0"    2> >($LOGCMD)
    else
        process_option_list_desktop_background
        process_option_list_user_photo
        process_option_list_favorite_apps
    fi

    info '
De gegevens zijn vastgelegd in Persoonlijke map / kz-data.
In map kz-data de bestanden met de eerder gebruikte Achtergrond,
Gebruikersfoto, en Favorieten.
Deze bestanden kunnen worden gebruikt voor het nalopen van het instellen.'
}


function process_option_list_desktop_background {
    local picture_file=''

    printf '%s\n' "$text1"
    picture_file=$(
        gsettings get org.gnome.desktop.background picture-uri |
        sed --expression='s|%20| |g'    |
        sed --expression="s/'//g"       |
        sed --expression='s|file://||'
        )
    cp "$picture_file" "$file1" |& $LOGCMD || true
}


function process_option_list_user_photo {
    printf '%s\n' "$text2"
    cp /var/lib/AccountsService/icons/"$USER" "$file2" |& $LOGCMD || true
}


function process_option_list_favorite_apps {
    printf '%s\n' "$text3"
    gsettings get org.gnome.shell favorite-apps | tr , '\n' |
    cut --delimiter='_' --fields=1 > "$file3" |& $LOGCMD
    sed --in-place --expression='s|\[| |'           "$file3" |& $LOGCMD
    sed --in-place --expression='s|\]| |'           "$file3" |& $LOGCMD
    sed --in-place --expression="s/'//g"            "$file3" |& $LOGCMD
    sed --in-place --expression='s/org.gnome.//'    "$file3" |& $LOGCMD
    sed --in-place --expression='s/.desktop//'      "$file3" |& $LOGCMD
    {
        printf '\n %s\n' 'N.B.'
        printf ' %s\n'   'yelp = Hulp'
        printf ' %s\n'   'snap-store = Software'
     } >>  "$file3"
}


function process_cmds_file {
    local       app_description=''
    local       first_description_line=true
    local       operation='instellen'
    local       record=''
    local       recordtype=''
    local       write_app_description_line=true
    local -i    app_seq_num=0
    local -i    app_tot_num=0
    local -i    cmd_seq_num=0

    app_tot_num=$(
        grep --word-regexp --regexp='^#1' --count "$CMDS_FILE" || true
        )
    if [[ $app_tot_num -gt 99 ]]; then
        app_tot_num=99
    fi

    if $OPTION_RESET; then
        operation='resetten'
    fi
    if $OPTION_SIMULATE; then
        operation+=' simuleren'
    else
        STATUS_BUSY="[${BLINK}WERK${NORMAL}]"
        STATUS_ERROR="[${RED}FOUT${NORMAL}]"
        STATUS_SUCCESS="[${GREEN}GOED${NORMAL}]"
        printf '%s' "${CURSOR_INVISABLE}"
    fi

    while read -r record; do
        recordtype=${record:0:2}
        case $recordtype in
            '')
                # Lege regel of lege app-naam.
                continue
                ;;
            '#1')
                # Appnaam en -beschrijving.
                process_app_description_record "$record"
                ;;
            '#2')
                # Resetopdracht.
                if $OPTION_RESET; then
                    process_command_record "${record:3}"
                fi
                ;;
            '#'*)
                # Commentaarregel.
                continue
                ;;
            *)
                # Instelopdracht.
                if ! $OPTION_RESET; then
                    process_command_record "$record"
                fi
                ;;
        esac
    done < "$CMDS_FILE"

    printf '%s' "${CURSOR_VISABLE}"
}


function process_app_description_record {
    local record=${1:-record?}

    app_description="${record:3} $operation"
    write_app_description_line=true
    ((++app_seq_num))
    if [[ $app_seq_num -gt 99 ]]; then
        app_seq_num=99
    fi
    cmd_seq_num=0
}


function process_command_record {
    local       cmd=${1:-cmd?}
    local       app_description_line=''
    local -i    cmd_rc=0
    local -i    desc_maxlen=1000
    local       desc_printf=''
    local       status=''

    COMMANDS_FOUND=true
    ((++cmd_seq_num))
    if [[ $cmd_seq_num -gt 99 ]]; then
        cmd_seq_num=99
    fi

    if $EXECUTE_COMMANDS; then
        log "$DASHES"
        desc_printf=$app_description
        if $OPTION_GUI; then
            TEXT="#[$app_seq_num/$app_tot_num] $app_description\n\n$cmd"
            printf '%s\n' "$TEXT"
        else
            # Afbreken tekst in Terminalvenster moet i.v.m. updaten status.
            #  <--------------- tput cols --------------->
            # '[WERK] [ 1/1 ] [ 1] Te lange description...' <=== op 1 regel
            #  <------- 20 ------->                    <3>
            desc_maxlen=$(($(tput cols) - 20))
            if [[ ${#desc_printf} -gt $desc_maxlen ]]; then
                desc_printf=${desc_printf:0:(($desc_maxlen - 3))}'...'
            fi
        fi
        printf  -v app_description_line                             \
                "[%2d/%-2d] [%2d] %-${desc_maxlen}.${desc_maxlen}s" \
                "$app_seq_num"                                      \
                "$app_tot_num"                                      \
                "$cmd_seq_num"                                      \
                "$desc_printf"
        execute_command "$cmd"
    else
        if $write_app_description_line; then
            if $first_description_line; then
                first_description_line=false
            else
                printf '\n' >> "$SIM_FILE"
            fi
            printf  '[%2d/%-2d] %s\n'   \
                    "$app_seq_num"      \
                    "$app_tot_num"      \
                    "$app_description"  >> "$SIM_FILE"
            write_app_description_line=false
        fi
        printf  '%7s [%2d] %s\n'        \
                " "                     \
                "$cmd_seq_num"          \
                "${BLUE}$cmd${NORMAL}"  >> "$SIM_FILE"
    fi
}


function execute_command {
    local       cmd=${1:-cmd?}
    local -i    cmd_rc=0
    local       status=''

    if ! $OPTION_GUI; then
        if [[ $cmd_seq_num -eq 1 ]]; then
            printf "$STATUS_BUSY %b" "$app_description_line\r"
        else
            printf "$STATUS_BUSY        %b" "${app_description_line:7}\r"
        fi
    fi

    log "$app_description_line"
    log "${BLUE}$cmd${NORMAL}"
    NOERROR=true
    eval "$cmd" |& $LOGCMD || cmd_rc=$?
    NOERROR=false
    if [[ $cmd_rc -gt $MAXRC ]]; then
        MAXRC=$cmd_rc
    fi
    if [[ $cmd_rc -eq $SUCCESS ]]; then
        status="$STATUS_SUCCESS"
    else
        status="$STATUS_ERROR"
    fi
    log "$status rc=$cmd_rc, maxrc=$MAXRC"
    if ! $OPTION_GUI; then
        printf '%s\n' "$status"
    fi
}


function term_script {
    local action='Instellen'

    if ! $COMMANDS_FOUND; then
        info 'Geen opdrachten om uit te voeren.'
    elif $EXECUTE_COMMANDS; then
        if [[ $MAXRC -ne $SUCCESS ]]; then
            exit $ERROR
        else
            if $OPTION_RESET; then
                action='Resetten'
            fi
            info "
$action is voltooid."
        fi
    else
        less "$LESS_OPTIONS" "$SIM_FILE"
    fi
    exit $SUCCESS
}


###############################################################################
# Script
###############################################################################

function main {
    init_script "$@"
    check_input "$@"
    process_input
    term_script
}

main "$@"
