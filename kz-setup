#!/bin/bash
# shellcheck source=kz-common.sh
###############################################################################
# Apps instellen.                                                             #
#                                                                             #
# Geschreven door Karel Zimmer <info@karelzimmer.nl>.                         #
###############################################################################

PROGRAM_PATH=$(realpath "$(dirname  "$0")")
readonly PROGRAM_PATH
source  "$PROGRAM_PATH"/kz-common.sh
readonly PROGRAM_NAME='kz-setup'
readonly DISPLAY_NAME=${PROGRAM_NAME/kz-/kz }
readonly RELEASE_YEAR=2013

###############################################################################
# Global constants                                                            #
###############################################################################

readonly OPTIONS_SHORT=$OPTIONS_SHORT_COMMON'ace:fglrs'
readonly OPTIONS_LONG=$OPTIONS_LONG_COMMON",apps,cat,edition:,files,gui,list,\
reset,simulate"
readonly USAGE="Gebruik: $DISPLAY_NAME [-a|--apps] [-c|--cat] \
[-e|--edition=EDITIE] [-f|--files]
                  [-g|--gui] [-l|--list] [-r|--reset] [-s|--simulate]
                  $OPTIONS_USAGE_COMMON
                  [APP...] [BESTAND...]"
readonly HELP="Gebruik: $DISPLAY_NAME [OPTIE...] [APP...] [BESTAND...]

Apps instellen.

Opties:
  -a, --apps     toon lijst van beschikbare apps
  -c, --cat      toon inhoud van bestanden
  -e, --edition=EDITIE
                 gebruik opgegeven EDITIE
  -f, --files    toon lijst van bestanden
  -g, --gui      start in grafische modus
  -l, --list     maak instellijst aan
  -r, --reset    toon reset-instructies
  -s, --simulate toon opdrachten
$OPTIONS_HELP_COMMON

Argumenten:
  APP            opgegeven APPs instellen
  BESTAND        opgegeven BESTANDen verwerken"

readonly EDITION_DEFAULT=desktop
SPACES=$(printf '%.0s ' {1..79})
readonly SPACES
VERSION=$(lsb_release --release --short)
readonly VERSION
CMDS_FILE=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.cmds")
readonly CMDS_FILE
APPS_FILE=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.sh")
readonly APPS_FILE
TEXT_FILE=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.text")
readonly TEXT_FILE

###############################################################################
# Global variables                                                            #
###############################################################################

declare -a  APP_ARGUMENTS=()
declare     ARGUMENT_APP=false
declare     ARGUMENT_FILE=false
declare     COMMANDS_FOUND=false
declare     EDITION=$EDITION_DEFAULT
declare     EDITION_ARGUMENT=''
declare     EXECUTE_COMMANDS=true
declare -a  FILE_ARGUMENTS=()
declare -a  FILES_TO_PROCESS=()
declare     LESS_OPTIONS=''
declare -i  MAXRC=0
declare     OPTION_APPS=false
declare     OPTION_CAT=false
declare     OPTION_EDITION=false
declare     OPTION_FILES=false
declare     OPTION_GUI=false
declare     OPTION_LIST=false
declare     OPTION_RESET=false
declare     OPTION_SIMULATE=false
declare     STATUS_BUSY=''

# Terminalattributen, zie 'man terminfo'.  Gebruik ${<variabele-naam>}.
declare     BLINK=''
declare     CARRIAGE_RETURN=''
declare     CURSOR_INVISABLE=''
declare     CURSOR_VISABLE=''

###############################################################################
# Functions                                                                   #
###############################################################################

function check_input {
    local -i    app_arg_num=0
    local -i    file_arg_num=0
    local -i    getopt_rc=0
    local       parsed=''

    parsed=$(
        getopt  --alternative                       \
                --options       "$OPTIONS_SHORT"    \
                --longoptions   "$OPTIONS_LONG"     \
                --name          "$DISPLAY_NAME"     \
                --              "$@"
        )       || getopt_rc=$?
    if [[ $getopt_rc -ne $SUCCESS ]]; then
        info "$USAGELINE" >&2
        exit $ERROR
    fi
    eval set -- "$parsed"
    process_common_options "$@"
    STATUS_ERROR="[${RED}FOUT${NORMAL}]"
    STATUS_SUCCESS="[${GREEN}GOED${NORMAL}]"

    while true; do
        case $1 in
            -a|--apps)
                OPTION_APPS=true
                shift
                ;;
            -c|--cat)
                OPTION_CAT=true
                shift
                ;;
            -e|--edition)
                if $OPTION_EDITION; then
                    error "Optie '$1' eenmaal opgeven."
                    info "$USAGELINE" >&2
                    exit $ERROR
                else
                    OPTION_EDITION=true
                    EDITION_ARGUMENT=$2
                    EDITION=$EDITION_ARGUMENT
                fi
                shift 2
                ;;
            -f|--files)
                OPTION_FILES=true
                shift
                ;;
            -g|--gui)
                OPTION_GUI=true
                if [[ -t 1 ]]; then
                    reset_terminal_attributes
                fi
                shift
                ;;
            -l|--list)
                OPTION_LIST=true
                shift
                ;;
            -r|--reset)
                OPTION_RESET=true
                shift
                ;;
            -s|--simulate)
                OPTION_SIMULATE=true
                EXECUTE_COMMANDS=false
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                shift
                ;;
        esac
    done

    # Verwerk argumenten.
    while [[ "$*" ]]; do
        if [[ "$(basename "$1")" == $PROGRAM_NAME-*.sh ]]; then
            ARGUMENT_FILE=true
            FILE_ARGUMENTS[$file_arg_num]=$1
            ((++file_arg_num))
            shift
        else
            ARGUMENT_APP=true
            APP_ARGUMENTS[$app_arg_num]=$1
            ((++app_arg_num))
            shift
        fi
    done

    if [[ -t 1 ]]; then
        BLINK=$(tput blink)
        CARRIAGE_RETURN=$(tput cr)
        CURSOR_INVISABLE=$(tput civis)
        CURSOR_VISABLE=$(tput cvvis)
    fi
}

function process_input {
    local -i    app_seq_num=0
    local -i    app_tot_num=0
    local       dfltfile_1=''
    local       dfltfile_2=''
    local       file_notfound=false
    local -i    file_num=0
    local       file=''
    local       skip_line=false

    # Verwerk optie list.
    if $OPTION_LIST; then
        check_user
        process_option_list
        exit $SUCCESS
    fi

    # Verwerk argumenten.
    dfltfile_1=$PROGRAM_PATH/$PROGRAM_NAME-$DISTRO-$VERSION-$EDITION.sh
    dfltfile_2=$PROGRAM_PATH/$PROGRAM_NAME-$DISTRO-$VERSION-$EDITION\
-$HOSTNAME.sh
    if $ARGUMENT_APP; then
        process_argument_app
    fi
    if $ARGUMENT_FILE; then
        process_argument_file
    fi
    # Ergens hiervoor ging het niet helemaal goed.
    if $file_notfound; then
        exit $SUCCESS
    fi
    # Voor bepaalde argumenten en opties geen standaardbestanden verwerken.
    if ! ($ARGUMENT_APP || $ARGUMENT_FILE || $OPTION_FILES); then
        process_dfltfiles
    fi

    # Verwerk overige opties; afhankelijk van bestanden en argumenten.
    if $OPTION_APPS; then
        process_option_apps
        exit $SUCCESS
    elif $OPTION_CAT; then
        process_option_cat
        exit $SUCCESS
    elif $OPTION_FILES; then
        process_option_files
        exit $SUCCESS
    fi

    # Opdrachten uitvoeren of simuleren.
    if $EXECUTE_COMMANDS; then
        check_user
    fi

    for file in "${FILES_TO_PROCESS[@]}"; do
        cat "$file" >> "$CMDS_FILE"
    done

    app_tot_num=$(
        grep --word-regexp --regexp='^#1' --count "$CMDS_FILE" || true
        )

    if $EXECUTE_COMMANDS && $OPTION_GUI; then
        TITLE='Apps instellen'
        TEXT=''
        # Met "|& zenity --progress" worden globale variabelen uit aangeroepen
        # functies niet doorgegeven, vandaar de 'process substitution' met
        # "> >(zenity...)".
        process_file > >(
            zenity  --progress              \
                    --pulsate               \
                    --auto-close            \
                    --no-cancel             \
                    --width     700         \
                    --height    50          \
                    --title     "$TITLE"    \
                    --text      "$TEXT"     2> >($LOGCMD)
            )
    else
        process_file
    fi
}

function process_argument_app {
    local       app=''
    local       file=''
    local -a    files=()
    local       temp_file=''

    # Verplicht aanwezig.
    if [[ -e $dfltfile_1 ]]; then
        files[0]=$dfltfile_1
    else
        info "Geen bestanden gevonden voor $DISTRO $VERSION $EDITION."
        exit $WARNING
    fi
    # Niet verplicht aanwezig.
    if [[ -e $dfltfile_2 ]]; then
        files[1]=$dfltfile_2
    fi

    # kz-install zoekt naar apps in ALLE kz-install-<distro>-<versie>-bestanden
    # en stopt bij de eerstgevonden, kz-setup zoekt naar apps ALLEEN in de
    # staandaard bestanden kz-setup-<distro>-<versie>-<editie>.sh en
    # kz-install-<distro>-<versie>-<editie>-<computernaam>.sh.
    temp_file=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.temp")
    cat "${files[@]}" > "$temp_file"
    for app in "${APP_ARGUMENTS[@]}"; do
        if ! grep   --files-with-matches    \
                    --word-regexp           \
                    --regexp="#1 $app"      \
                    "${files[@]}"           \
                    &> /dev/null; then
            warning "App '$app' niet gevonden."
            file_notfound=true
        else
            process_argument_app_file
        fi
    done
    rm "$temp_file" |& $LOGCMD
    if $file_notfound; then
        info "Typ '$DISPLAY_NAME --apps' voor beschikbare apps." >&2
    else
        FILES_TO_PROCESS[$file_num]=$APPS_FILE
        ((++file_num))
    fi
}

function process_argument_app_file {
    local app_found=false
    local record=''

    while read -r record; do
        case $record in
            '#1 '*)
                if [[ $record == '#1 '$app* ]]; then
                    # Gezochte app-naam.
                    # Regels doorschrijven naar tijdelijk bestand tot
                    # eerstvolgende app-naam of tot eof.
                    app_found=true
                    echo "$record" >> "$APPS_FILE"
                elif $app_found; then
                    # Volgende app.
                    app_found=false
                    continue
                fi
                ;;
            '#1-'*)
                if $app_found; then
                    # Volgende (hidden) app.
                    break
                fi
                ;;
            *)
                # Overige regels.
                if $app_found; then
                    echo "$record" >> "$APPS_FILE"
                fi
                ;;
        esac
    done < "$temp_file"
}

function process_argument_file {
    local file=''

    for file in "${FILE_ARGUMENTS[@]}"; do
        if [[ -e $file ]]; then
            FILES_TO_PROCESS[$file_num]=$file
            ((++file_num))
        else
            warning "Bestand $file niet gevonden."
            file_notfound=true
        fi
    done
    if $file_notfound; then
        info "Typ '$DISPLAY_NAME --files' voor bestanden op dit systeem." >&2
    fi
}

function process_dfltfiles {
    # Verplicht aanwezig.
    if [[ -e $dfltfile_1 ]]; then
        FILES_TO_PROCESS[$file_num]=$dfltfile_1
        ((++file_num))
    else
        warning "Geen bestanden gevonden voor $DISTRO $VERSION $EDITION." >&2
        info "$USAGELINE" >&2
        exit $WARNING
    fi
    # Niet verplicht aanwezig.
    if [[ -e $dfltfile_2 ]]; then
        FILES_TO_PROCESS[$file_num]=$dfltfile_2
        ((++file_num))
    fi
}

function process_option_apps {
    # kz-install zoekt naar apps in ALLE kz-install-<distro>-<versie>-bestanden
    # en stopt bij de eerstgevonden, kz-setup zoekt naar apps ALLEEN in de
    # staandaard bestanden kz-setup-<distro>-<versie>-<editie>.sh en
    # kz-install-<distro>-<versie>-<editie>-<computernaam>.sh.
    process_dfltfiles
    TEXT="De volgende apps zijn beschikbaar:

NUMMER APP (BESCHRIJVING)
$(
    if !    grep    --no-messages           \
                    --regexp='^#1 '         \
                    "${FILES_TO_PROCESS[@]}" |
            cut     --delimiter=' '         \
                    --fields=2-             |
            sort    --unique                |
            nl      --number-width=6        \
                    --number-format=rn      \
                    --number-separator=' '  \
                    --body-numbering=a; then
        printf '%s\n' "     0 Geen apps gevonden voor $DISTRO $VERSION."
    else
        printf '%s\n' "
Om APPs te bekijken voer uit:
    ${BLUE}$DISPLAY_NAME --sim APP...${NORMAL}
    ${BLUE}$DISPLAY_NAME --cat APP...${NORMAL}
Om APPs in te stellen voer uit:
    ${BLUE}$DISPLAY_NAME APP...${NORMAL}"
    fi
)"
    info "$TEXT"
}

function process_option_cat {
    local first_file=true

    for file in "${FILES_TO_PROCESS[@]}"; do
        {
            if $first_file; then
                first_file=false
            else
                echo
            fi
            echo "${BLUE}# $file${NORMAL}"
            cat "$file"
        }   >> "$CMDS_FILE"
    done
    less_options "$TITLE"
    less "$LESS_OPTIONS" "$CMDS_FILE"
}

function less_options {
    # Less-opties, overgenomen (en aangepast, zie 'man less', zoek PROMPTS)
    # van:
    # 1. systemctl en journalctl, zie bijvoorbeeld 'man systemctl', zoek LESS
    #    ("FRSXMK")
    # 2. man, zie 'man man', zoek LESS
    LESS_OPTIONS="--LONG-PROMPT --no-init --quit-if-one-screen --quit-on-intr \
--RAW-CONTROL-CHARS --prompt=M$1 ?ltregel %lt?L van %L.:byte %bB?s van %s..? \
.?e (EINDE) :?pB %pB\%. .(druk h voor hulp of q voor stoppen)"
}

function process_option_files {
    TEXT="De volgende bestanden staan op het systeem:

NUMMER BESTAND
$(
    if !    find    "$PROGRAM_PATH/$PROGRAM_NAME-"* \
                    2> /dev/null                    |
            nl      --number-width=6                \
                    --number-format=rn              \
                    --number-separator=' '          \
                    --body-numbering=a; then
        printf '%s\n' "     0 Geen bestanden aanwezig op het systeem.

$USAGELINE"
    else
        printf '%s\n' "
Om BESTANDen te bekijken voer uit:
    ${BLUE}$DISPLAY_NAME --sim BESTAND...${NORMAL}
    ${BLUE}$DISPLAY_NAME --cat BESTAND...${NORMAL}
Om BESTANDen te gebruiken voer uit:
    ${BLUE}$DISPLAY_NAME BESTAND...${NORMAL}"
    fi
)"
    info "$TEXT"
}

function process_option_list {
    if [[ -f "${XDG_CONFIG_HOME:-~/.config}"/user-dirs.dirs ]]; then
        source "${XDG_CONFIG_HOME:-~/.config}"/user-dirs.dirs
    fi
    local docs_dir=${XDG_DOCUMENTS_DIR:-$HOME/Documenten}/kz
    local text0='Opdrachten worden verwerkt'
    local text1='[1/4]  Gebruikersfoto vastleggen'
    local file1="$docs_dir/Gebruikersfoto"
    local text2='[2/4]  Bureaubladachtergrond vastleggen'
    local file2="$docs_dir/Bureaubladachtergrond"
    local text3='[3/4]  Favorieten vastleggen'
    local file3="$docs_dir/Favorieten"
    local text4='[4/4]  Opdrachtgeschiedenis vastleggen'
    local file4="$docs_dir/Opdrachtgeschiedenis"

    mkdir --parents "$docs_dir"

    TITLE='Instellijst maken'
    if $OPTION_GUI; then
        (
        printf '%s\n' "#$text1"
        process_option_list_user_photo
        printf '%s\n' "#$text2"
        process_option_list_desktop_background
        printf '%s\n' "#$text3"
        process_option_list_favorite_apps
        printf '%s\n' "#$text4"
        process_option_list_command_history
        ) |&
        zenity  --progress              \
                --pulsate               \
                --auto-close            \
                --no-cancel             \
                --width     600         \
                --height    50          \
                --title     "$TITLE"    \
                --text      "$text0"    2> >($LOGCMD)
    else
        process_option_list_user_photo
        process_option_list_desktop_background
        process_option_list_favorite_apps
        process_option_list_command_history
    fi

    info '
De instellingen zijn vastgelegd in de map kz in Documenten.
In map kz de bestanden met de eerder gebruikte Gebruikersfoto,
Bureaubladachtergrond, Favorieten, en Opdrachtgeschiedenis.
Deze bestanden kunnen worden gebruikt voor het nalopen van het instellen.'
}

function process_option_list_user_photo {
    printf '%s\n' "$text1..."
    if ! cp /var/lib/AccountsService/icons/"$USER" "$file1" |& $LOGCMD; then
        rm --force "$file1"
        touch "$file1"
    fi
}

function process_option_list_desktop_background {
    printf '%s\n' "$text2..."
    gsettings get   org.gnome.desktop.background    \
                    picture-uri                     > "$file2" |& $LOGCMD
}

function process_option_list_favorite_apps {
    printf '%s\n' "$text3..."
    gsettings get   org.gnome.shell \
                    favorite-apps   > "$file3" |& $LOGCMD
}

function process_option_list_command_history {
    printf '%s\n' "$text4..."
    HISTFILE=~/.bash_history
    set -o history
    history > "$file4" |& $LOGCMD
}

function process_file {
    local       app_description=''
    local -i    cmd_seq_num=0
    local       first_description_line=true
    local       record=''
    local       recordtype=''
    local       write_app_description_line=true

    if $EXECUTE_COMMANDS; then
        STATUS_BUSY="[${BLINK}${BOLD}WERK${NORMAL}]"
        printf '%b' "${CURSOR_INVISABLE}"
    fi
    $skip_line && printf '\n'; skip_line=true

    while read -r record; do
        recordtype=${record:0:2}
        case $recordtype in
            '')
                # Lege regel of lege app-naam.
                continue
                ;;
            '#1')
                process_app_description "$record"
                ;;
            '#2')
                if $OPTION_RESET; then
                    process_command "${record:3}"
                fi
                ;;
            '#'*)
                # Commentaarregel.
                continue
                ;;
            *)
                if ! $OPTION_RESET; then
                    process_command "$record"
                fi
                ;;
        esac
    done < "$CMDS_FILE"

    if $EXECUTE_COMMANDS; then
        printf '%b' "${CURSOR_VISABLE}"
    fi
}

function process_app_description {
    local record=${1:-record?}

    if $OPTION_SIMULATE && $OPTION_RESET; then
        app_description="${record:3}"' resetten simuleren'
    elif $OPTION_RESET; then
        app_description="${record:3}"' resetten'
    elif $OPTION_SIMULATE; then
        app_description="${record:3}"' instellen simuleren'
    else
        app_description="${record:3}"' instellen'
    fi
    if ! $OPTION_SIMULATE && ! $EXECUTE_COMMANDS; then
        return $SUCCESS
    fi
    write_app_description_line=true
    ((++app_seq_num))
    cmd_seq_num=0
}

function process_command {
    local       cmd=${1:-cmd?}
    local       app_description_line=''
    local -i    cmd_rc=0
    local -i    desc_maxlen=1000
    local       desc_printf=''
    local       status=''

    COMMANDS_FOUND=true
    ((++cmd_seq_num))

    if $OPTION_SIMULATE; then
        if $write_app_description_line; then
            if $first_description_line; then
                first_description_line=false
            else
                echo >> "$TEXT_FILE"
            fi
            printf  '[%3d/%-3d] %s\n'   \
                    "$app_seq_num"      \
                    "$app_tot_num"      \
                    "$app_description"  >> "$TEXT_FILE"
            write_app_description_line=false
        fi
        printf  '%9s [%2d] %s\n'            \
                " "                         \
                "$cmd_seq_num"              \
                "${BLUE}$cmd${NORMAL}"   >> "$TEXT_FILE"
    elif $EXECUTE_COMMANDS; then
        desc_printf=$app_description
        if $OPTION_GUI; then
            TEXT="#[$app_seq_num/$app_tot_num] $app_description\n\n$cmd"
            printf '%s\n' "$TEXT"
        else
            if [[ -t 1 ]]; then
                # Afbreken tekst in Terminalvenster moet i.v.m. updaten status.
                #  <------------- tput cols ------------->
                # '[WERK] [  1/1  ] [ 1] Te lange descr...' <=== op 1 regel
                #  <-------- 22 -------->
                desc_maxlen=$(($(tput cols) - 22))
                if [[ ${#desc_printf} -gt $desc_maxlen ]]; then
                    desc_printf=${desc_printf:0:(($desc_maxlen - 3))}'...'
                fi
            fi
        fi
        printf  -v app_description_line                             \
                "[%3d/%-3d] [%2d] %-${desc_maxlen}.${desc_maxlen}s" \
                "$app_seq_num"                                      \
                "$app_tot_num"                                      \
                "$cmd_seq_num"                                      \
                "$desc_printf"
        execute_command "$cmd"
    fi
}

function execute_command {
    local       cmd=${1:-cmd?}
    local -i    cmd_rc=0
    local       status=''

    if ! $OPTION_GUI; then
        if [[ $cmd_seq_num -eq 1 ]]; then
            printf "$STATUS_BUSY %s${CARRIAGE_RETURN}" "$app_description_line"
        else
            printf  "$STATUS_BUSY ${SPACES:0:9}%s${CARRIAGE_RETURN}" \
                    "${app_description_line:9}"
        fi
    fi

    log "$app_description_line"
    log "${BLUE}$cmd${NORMAL}"
    ERROR_MSG_TO_LOG=true
    eval "$cmd" |& $LOGCMD || cmd_rc=$?
    ERROR_MSG_TO_LOG=false
    if [[ $cmd_rc -gt $MAXRC ]]; then
        MAXRC=$cmd_rc
    fi
    if [[ $cmd_rc -eq $SUCCESS ]]; then
        status="$STATUS_SUCCESS"
    else
        status="$STATUS_ERROR"
    fi
    log "$status rc=$cmd_rc, maxrc=$MAXRC"
    if ! $OPTION_GUI; then
        printf '%s\n' "$status"
    fi
}

function term_script {
    local action='Instellen'

    if $OPTION_SIMULATE; then
        less_options "$TITLE"
        less "$LESS_OPTIONS" "$TEXT_FILE"
    elif ! $COMMANDS_FOUND; then
        info 'Geen opdrachten.'
    fi

    if $OPTION_RESET; then
        action='Resetten'
    fi
    if $EXECUTE_COMMANDS; then
        if [[ $MAXRC -ne $SUCCESS ]]; then
            warning "
$action is geëindigd met een waarschuwing.

Start een Terminalvenster en controleer de log met:
    ${BLUE}$LOGCMD_CHECK${NORMAL}"
            exit $WARNING
        else
            info "
${GREEN}$action is voltooid.${NORMAL}"
            exit $SUCCESS
        fi
    fi
}

###############################################################################
# Main line                                                                   #
###############################################################################

function main {
    init_script "$@"
    check_input "$@"
    process_input
    term_script
}

main "$@"
