#!/bin/bash
# shellcheck source=kz_common.sh
###############################################################################
# Bestandsnamen controleren.
#
# Geschreven door Karel Zimmer <info@karelzimmer.nl>.
###############################################################################
PROGRAM_PATH=$(realpath "$(dirname  "$0")")
source "$PROGRAM_PATH"/kz_common.sh
PROGRAM_NAME=kz_ckname
DISPLAY_NAME=${PROGRAM_NAME/kz_/kz }
RELEASE_YEAR=2012

VERSION_NUMBER=13.00.02
VERSION_DATE=2021-08-22


###############################################################################
# Global constants
###############################################################################

readonly    OPTIONS_SHORT=$OPTIONS_SHORT_COMMON
readonly    OPTIONS_LONG=$OPTIONS_LONG_COMMON
readonly    USAGE="Gebruik: $DISPLAY_NAME $OPTIONS_USAGE_COMMON [MAP...]"
readonly    HELP="Gebruik: $DISPLAY_NAME [OPTIE...] [--] [MAP...]

Bestandsnamen controleren.

Opties:
$OPTIONS_HELP_COMMON

Argumenten:
  MAP           begin te controleren vanaf map MAP"

declare -ir FILENAME_MAXLEN=142
readonly    START_DFLT=$HOME


###############################################################################
# Global variables
###############################################################################

declare     ARGUMENT_MAP=false
declare -a  MAP_ARGUMENT=''


###############################################################################
# Functions
###############################################################################

check_input() {
    local -i    map_arg_num=0
    local -i    getopt_rc=0
    local       parsed=''

    parsed=$(
        getopt  --alternative                       \
                --options       "$OPTIONS_SHORT"    \
                --longoptions   "$OPTIONS_LONG"     \
                --name          "$DISPLAY_NAME"     \
                --              "$@"
        )       || getopt_rc=$?
    if [[ $getopt_rc -ne $SUCCESS ]]; then
        printf '%s\n' "$USAGELINE" >&2
        exit $ERROR
    fi
    eval set -- "$parsed"
    process_general_options "$@"

    while true; do
        case $1 in
            --)
                shift
                break
                ;;
            *)
                shift
                ;;
        esac
    done

    while [[ "$*" ]]; do
        ARGUMENT_MAP=true
        MAP_ARGUMENT[$map_arg_num]=$1
        ((++map_arg_num))
        shift
    done
    if ! $ARGUMENT_MAP; then
        MAP_ARGUMENT[0]=$START_DFLT
    fi
    for dir in ${MAP_ARGUMENT[*]}; do
        if ! [[ -d $dir ]]; then
                TEXT="map '$dir' bestaat niet"
                printf  "$DISPLAY_NAME: %s\n%s\n"   \
                        "$TEXT"                     \
                        "$USAGELINE"                >&2
            exit $ERROR
        fi
    done

    # Een non-gui script gestart met optie gui.
    if $OPTION_GUI; then
        OPTION_GUI=false
        TERMINAL=true
    fi

    check_user
}


process_input() {
    check_files_and_folders
}


check_files_and_folders() {
    local       dirname
    local       file
    local       basename
    local       good
    local   -i  count=0

    # Het maakt niet uit of in de bestandsnaam speciale tekens voorkomen zoals
    # tab, spatie, enz.  Hiervoor zorgt de find met print0,en de read met IFS=
    # en als delimiter de null character die niet mag voorkomen in een
    # bestandsnaam.  N.B.: In Linux is alles een bestand!
    while IFS= read -r -d $'\0' file; do

        dirname=$(dirname "$file")
        basename=$(basename "$file")

        # Verwijder de slechte tekens, \ is escape voor " en :
        good=$(printf '%s'"$file" | tr --delete '?"\\<>*|:')

        if ! [[ $file = "$good" ]]; then
            ((++count))
            if [[ -d "$file" ]]; then
                info "BadName  DIR '$file'."
            elif [[ -f "$file" ]]; then
                info "BadName FILE '$basename' in map '$dirname'."
            else
                info "BadName SYML '$file'."
            fi
        fi

        if [[ ${#basename} -gt $FILENAME_MAXLEN ]]; then
            ((++count))
            if [[ -d "$file" ]]; then
                info "BadLen.  DIR '$basename'."
            else
                info "BadLen. FILE '$basename' in map '$dirname'."
            fi
        fi

    done < <(
        find    "${MAP_ARGUMENT[@]}"    \
                -type f                 \
                -print0                 \
                -or                     \
                -type d                 \
                -print0                 \
                -or                     \
                -type l                 \
                -print0
        )

    if [[ $count -eq 0 ]]; then
        return $SUCCESS
    elif [[ $count -eq 1 ]]; then
        warning 'Er is een fout gevonden.'
    else
        warning "Er zijn $count fouten gevonden."
    fi
}


term_script() {
    exit $SUCCESS
}


###############################################################################
# Main line
###############################################################################

main() {
    init_script
    check_input "$@"
    process_input
    term_script
}


main "$@"


# EOF
