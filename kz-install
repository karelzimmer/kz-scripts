#!/usr/bin/bash
# shellcheck source=kz-common.sh
###############################################################################
# Apps installeren.                                                           #
#                                                                             #
# Geschreven door Karel Zimmer <info@karelzimmer.nl>.                         #
###############################################################################

PROGRAM_PATH=$(realpath "$(dirname  "$0")")
readonly PROGRAM_PATH
source  "$PROGRAM_PATH"/kz-common.sh
readonly PROGRAM_NAME='kz-install'
readonly DISPLAY_NAME=${PROGRAM_NAME/kz-/kz }
readonly RELEASE_YEAR=2009

###############################################################################
# Global constants                                                            #
###############################################################################

readonly OPTIONS_SHORT=$OPTIONS_SHORT_COMMON'ace:fglrs'
readonly OPTIONS_LONG=$OPTIONS_LONG_COMMON",apps,cat,edition:,files,gui,list,\
remove,simulate"
readonly USAGE="Gebruik: $DISPLAY_NAME [-a|--apps] [-c|--cat] \
[-e|--edition=EDITIE] [-f|--files]
                    [-g|--gui] [-l|--list] [-r|--remove] [-s|--simulate]
                    $OPTIONS_USAGE_COMMON
                    [APP...] [BESTAND...]"
readonly HELP="Gebruik: $DISPLAY_NAME [OPTIE...] [APP...] [BESTAND...]

Apps installeren.

Opties:
  -a, --apps     toon lijst van beschikbare apps
  -c, --cat      toon inhoud van bestanden
  -e, --edition=EDITIE
                 gebruik opgegeven EDITIE
  -f, --files    toon lijst van bestanden
  -g, --gui      start in grafische modus
  -l, --list     maak applijst aan
  -r, --remove   toon verwijder-instructies
  -s, --simulate toon opdrachten
$OPTIONS_HELP_COMMON

Argumenten:
  APP            opgegeven APPs installeren
  BESTAND        opgegeven BESTANDen verwerken"

DASHES=$(printf '%.0s=' {1..79})
readonly DASHES
readonly EDITION_DEFAULT=desktop
SPACES=$(printf '%.0s ' {1..79})
readonly SPACES
VERSION=$(lsb_release --release --short)
readonly VERSION
CMDS_FILE=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.cmds")
readonly CMDS_FILE
APPS_FILE=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.sh")
readonly APPS_FILE
TEXT_FILE=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.text")
readonly TEXT_FILE
TEMP_LIST=$(mktemp -t "$PROGRAM_NAME-XXXXXXXXXX.list")
readonly TEMP_LIST

###############################################################################
# Global variables                                                            #
###############################################################################

declare -a  APP_ARGUMENTS=()
declare     ARGUMENT_APP=false
declare     ARGUMENT_FILE=false
declare     COMMANDS_FOUND=false
declare     EDITION=$EDITION_DEFAULT
declare     EDITION_ARGUMENT=''
declare     EXECUTE_COMMANDS=true
declare -a  FILE_ARGUMENTS=()
declare -a  FILES_TO_PROCESS=()
declare     LESS_OPTIONS=''
declare -i  MAXRC=0
declare     OPTION_APPS=false
declare     OPTION_CAT=false
declare     OPTION_EDITION=false
declare     OPTION_FILES=false
declare     OPTION_GUI=false
declare     OPTION_LIST=false
declare     OPTION_REMOVE=false
declare     OPTION_SIMULATE=false
declare     REMOVE_FOUND=false
declare     RUN_AS_SUPERUSER=true
declare     STATUS_BUSY=''

# Terminalattributen, zie 'man terminfo'.  Gebruik ${<variabele-naam>}.
declare     BLINK=''
declare     CARRIAGE_RETURN=''
declare     CURSOR_INVISABLE=''
declare     CURSOR_VISABLE=''

###############################################################################
# Functions                                                                   #
###############################################################################

function check_input {
    local -i    app_arg_num=0
    local -i    file_arg_num=0
    local -i    getopt_rc=0
    local       other_option=''
    local       parsed=''

    parsed=$(
        getopt  --alternative                       \
                --options       "$OPTIONS_SHORT"    \
                --longoptions   "$OPTIONS_LONG"     \
                --name          "$DISPLAY_NAME"     \
                --              "$@"
        )       || getopt_rc=$?
    if [[ $getopt_rc -ne $SUCCESS ]]; then
        info "$USAGELINE" >&2
        exit $ERROR
    fi
    eval set -- "$parsed"
    process_common_options "$@"
    STATUS_ERROR="[${RED}FOUT${NORMAL}]"
    STATUS_SUCCESS="[${GREEN}GOED${NORMAL}]"

    while true; do
        case $1 in
            -a|--apps)
                OPTION_APPS=true
                shift
                ;;
            -c|--cat)
                OPTION_CAT=true
                shift
                ;;
            -e|--edition)
                if $OPTION_EDITION; then
                    error "Optie '$1' eenmaal opgeven."
                    info "$USAGELINE" >&2
                    exit $ERROR
                else
                    OPTION_EDITION=true
                    EDITION_ARGUMENT=$2
                    EDITION=$EDITION_ARGUMENT
                fi
                shift 2
                ;;
            -f|--files)
                OPTION_FILES=true
                shift
                ;;
            -g|--gui)
                OPTION_GUI=true
                if [[ -t 1 ]]; then
                    reset_terminal_attributes
                fi
                shift
                ;;
            -l|--list)
                OPTION_LIST=true
                EXECUTE_COMMANDS=false
                shift
                ;;
            -r|--remove)
                if $OPTION_SIMULATE; then
                    error "Optie $1 kan niet samen met opie $other_option."
                    info "$USAGELINE" >&2
                    exit $ERROR
                fi
                other_option=$1
                OPTION_REMOVE=true
                EXECUTE_COMMANDS=false
                shift
                ;;
            -s|--simulate)
                if $OPTION_REMOVE; then
                    error "Optie $1 kan niet samen met opie $other_option."
                    info "$USAGELINE" >&2
                    exit $ERROR
                fi
                other_option=$1
                OPTION_SIMULATE=true
                EXECUTE_COMMANDS=false
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                shift
                ;;
        esac
    done

    # Verwerk argumenten.
    while [[ "$*" ]]; do
        if [[ "$(basename "$1")" == $PROGRAM_NAME-*.sh ]]; then
            ARGUMENT_FILE=true
            FILE_ARGUMENTS[$file_arg_num]=$1
            ((++file_arg_num))
            shift
        else
            ARGUMENT_APP=true
            APP_ARGUMENTS[$app_arg_num]=$1
            ((++app_arg_num))
            shift
        fi
    done

    if [[ -t 1 ]]; then
        BLINK=$(tput blink)
        CARRIAGE_RETURN=$(tput cr)
        CURSOR_INVISABLE=$(tput civis)
        CURSOR_VISABLE=$(tput cvvis)
    fi
}

function process_input {
    local -i    app_seq_num=0
    local -i    app_tot_num=0
    local       dfltfile_1=''
    local       dfltfile_2=''
    local       file_notfound=false
    local -i    file_num=0
    local       file=''
    local       skip_line=false

    dfltfile_1=$PROGRAM_PATH/$PROGRAM_NAME-$DISTRO-$VERSION-$EDITION.sh
    dfltfile_2=$PROGRAM_PATH/$PROGRAM_NAME-$DISTRO-$VERSION-$EDITION\
-$HOSTNAME.sh

    # Verwerk argumenten.
    if $ARGUMENT_APP; then
        process_argument_app
    fi
    if $ARGUMENT_FILE; then
        process_argument_file
    fi
    # Ergens hiervoor ging het niet helemaal goed.
    if $file_notfound; then
        exit $SUCCESS
    fi
    # Voor bepaalde argumenten en opties geen standaardbestanden verwerken.
    if ! ($ARGUMENT_APP || $ARGUMENT_FILE || $OPTION_FILES); then
        process_dfltfiles
    fi

    # Verwerk opties.
    if $OPTION_APPS; then
        process_option_apps
        exit $SUCCESS
    elif $OPTION_CAT; then
        process_option_cat
        exit $SUCCESS
    elif $OPTION_FILES; then
        process_option_files
        exit $SUCCESS
    elif $OPTION_LIST; then
        RUN_AS_SUPERUSER=false
        check_user
        process_option_list
        exit $SUCCESS
    fi

    # Opdrachten uitvoeren of simuleren.
    if $EXECUTE_COMMANDS; then
        check_user
        check_on_ac_power
    fi

    for file in "${FILES_TO_PROCESS[@]}"; do
        cat "$file" >> "$CMDS_FILE"
    done

    app_tot_num=$(
        grep --word-regexp --regexp='^#1' --count "$CMDS_FILE" || true
        )

    if $EXECUTE_COMMANDS && $OPTION_GUI; then
        TITLE='Apps installeren'
        TEXT=''
        # Met "|& zenity --progress" worden globale variabelen uit aangeroepen
        # functies niet doorgegeven, vandaar de 'process substitution' met
        # "> >(zenity...)".
        process_file > >(
            zenity  --progress              \
                    --pulsate               \
                    --auto-close            \
                    --no-cancel             \
                    --width     700         \
                    --height    50          \
                    --title     "$TITLE"    \
                    --text      "$TEXT"     2> >($LOGCMD)
            )
    else
        process_file
    fi
}

function process_argument_app {
    local       app=''
    local       file=''
    local -a    files=()
    local       search=''

    # kz-install zoekt naar apps in ALLE kz-install-<distro>-<versie>-bestanden
    # en stopt bij de eerstgevonden, kz-setup zoekt naar apps ALLEEN in de
    # staandaard bestanden kz-setup-<distro>-<versie>-<editie>.sh en
    # kz-install-<distro>-<versie>-<editie>-<computernaam>.sh.
    search=$PROGRAM_NAME-$DISTRO-$VERSION
    for file in "$PROGRAM_PATH/$search"*.sh; do
        files+=("$file")
    done
    for app in "${APP_ARGUMENTS[@]}"; do
        file=$(
            grep    --files-with-matches    \
                    --word-regexp           \
                    --regexp="#1 $app"      \
                    "${files[@]}"           \
                    2> /dev/null            |
            head    --lines=1               || printf '\n'
            )
        if [[ $file ]]; then
            process_argument_app_file
        else
            warning "App '$app' niet gevonden."
            file_notfound=true
        fi
    done
    if $file_notfound; then
        info "Typ '$DISPLAY_NAME --apps' voor beschikbare apps." >&2
    else
        FILES_TO_PROCESS[$file_num]=$APPS_FILE
        ((++file_num))
    fi
}

function process_argument_app_file {
    local app_found=false
    local record=''

    while read -r record; do
        case $record in
            '#1 '*)
                if [[ $record == '#1 '$app* ]]; then
                    # Gezochte app-naam.
                    # Regels doorschrijven naar tijdelijk bestand tot
                    # eerstvolgende app-naam of tot eof.
                    printf '%s\n' "$record" >> "$APPS_FILE"
                    app_found=true
                elif $app_found; then
                    # Volgende app.
                    break
                fi
                ;;
            '#1-'*)
                if $app_found; then
                    # Volgende (hidden) app.
                    break
                fi
                ;;
            *)
                # Overige regels.
                if $app_found; then
                    printf '%s\n' "$record" >> "$APPS_FILE"
                fi
                ;;
        esac
    done < "$file"
}

function process_argument_file {
    local file=''

    for file in "${FILE_ARGUMENTS[@]}"; do
        if [[ -e $file ]]; then
            FILES_TO_PROCESS[$file_num]=$file
            ((++file_num))
        else
            warning "Bestand $file niet gevonden."
            file_notfound=true
        fi
    done
    if $file_notfound; then
        info "Typ '$DISPLAY_NAME --files' voor bestanden op dit systeem." >&2
    fi
}

function process_dfltfiles {
    # Verplicht aanwezig.
    if [[ -e $dfltfile_1 ]]; then
        FILES_TO_PROCESS[$file_num]=$dfltfile_1
        ((++file_num))
    else
        warning "Geen bestanden gevonden voor $DISTRO $VERSION $EDITION."
        info "$USAGELINE" >&2
        exit $WARNING
    fi
    # Niet verplicht aanwezig.
    if [[ -e $dfltfile_2 ]]; then
        FILES_TO_PROCESS[$file_num]=$dfltfile_2
        ((++file_num))
    fi
}

function process_option_apps {
    local -a    files=()
    local       search=''

    # kz-install zoekt naar apps in ALLE kz-install-<distro>-<versie>-bestanden
    # en stopt bij de eerstgevonden, kz-setup zoekt naar apps ALLEEN in de
    # staandaard bestanden kz-setup-<distro>-<versie>-<editie>.sh en
    # kz-install-<distro>-<versie>-<editie>-<computernaam>.sh.
    search=$PROGRAM_NAME-$DISTRO-$VERSION
    for file in "$PROGRAM_PATH/$search"*.sh; do
        files+=("$file")
    done
    TEXT="De volgende apps zijn beschikbaar:

NUMMER APP (BESCHRIJVING)
$(
    if !    grep    --no-messages           \
                    --regexp='^#1 '         \
                    "${files[@]}"           |
            cut     --delimiter=' '         \
                    --fields=2-             |
            sort    --unique                |
            nl      --number-width=6        \
                    --number-format=rn      \
                    --number-separator=' '  \
                    --body-numbering=a; then
        printf '%s\n' "     0 Geen apps gevonden voor $DISTRO $VERSION."
    else
        printf '%s\n' "
Om APPs te bekijken voer uit:
    ${BLUE}$DISPLAY_NAME --sim APP...${NORMAL}
    ${BLUE}$DISPLAY_NAME --cat APP...${NORMAL}
Om APPs te installeren voer uit:
    ${BLUE}$DISPLAY_NAME APP...${NORMAL}"
    fi
)"
    info "$TEXT"
}

function process_option_cat {
    local first_file=true

    for file in "${FILES_TO_PROCESS[@]}"; do
        {
            if $first_file; then
                first_file=false
            else
                printf '\n'
            fi
            printf '%s\n' "${BLUE}# $file${NORMAL}"
            cat "$file"
        }   >> "$CMDS_FILE"
    done
    less_options "$TITLE"
    less "$LESS_OPTIONS" "$CMDS_FILE"
}

function less_options {
    # Less-opties, overgenomen (en aangepast, zie 'man less', zoek PROMPTS)
    # van:
    # 1. systemctl en journalctl, zie bijvoorbeeld 'man systemctl', zoek LESS
    #    ("FRSXMK")
    # 2. man, zie 'man man', zoek LESS
    LESS_OPTIONS="--LONG-PROMPT --no-init --quit-if-one-screen --quit-on-intr \
--RAW-CONTROL-CHARS --prompt=M$1 ?ltregel %lt?L van %L.:byte %bB?s van %s..? \
.?e (EINDE) :?pB %pB\%. .(druk h voor hulp of q voor stoppen)"
}

function process_option_files {
    TEXT="De volgende bestanden staan op het systeem:

NUMMER BESTAND
$(
    if !    find    "$PROGRAM_PATH/$PROGRAM_NAME-"* \
                    2> /dev/null                    |
            nl      --number-width=6                \
                    --number-format=rn              \
                    --number-separator=' '          \
                    --body-numbering=a; then
        printf '%s\n' "     0 Geen bestanden aanwezig op het systeem.

$USAGELINE"
    else
        printf '%s\n' "
Om BESTANDen te bekijken voer uit:
    ${BLUE}$DISPLAY_NAME --sim BESTAND...${NORMAL}
    ${BLUE}$DISPLAY_NAME --cat BESTAND...${NORMAL}
Om BESTANDen te gebruiken voer uit:
    ${BLUE}$DISPLAY_NAME BESTAND...${NORMAL}"
    fi
)"
    info "$TEXT"
}

function process_option_list {
    local text0='Opdrachten worden verwerkt'
    local text1="[1/3]  Bepaal welke pakketten handmatig zijn geïnstalleerd"
    local text3='[2/3]  Bepaal welke snaps zijn geïnstalleerd'
    local text2="[3/3]  Bepaal welke pakketbronnen zijn toegevoegd"
    if [[ -f "${XDG_CONFIG_HOME:-~/.config}"/user-dirs.dirs ]]; then
        source "${XDG_CONFIG_HOME:-~/.config}"/user-dirs.dirs
    fi
    local docs_dir=${XDG_DOCUMENTS_DIR:-$HOME/Documenten}/kz
    local app_list=$docs_dir/Applijst

    mkdir --parents "$docs_dir" |& $LOGCMD

    TITLE='Applijst maken'
    if $OPTION_GUI; then
        (
        printf '%s\n' "#$text1"
        process_option_list_manual_installed
        printf '%s\n' "#$text2"
        process_option_list_snaps
        printf '%s\n' "#$text3"
        process_option_list_added_repos
        ) |&
        zenity  --progress              \
                --pulsate               \
                --auto-close            \
                --no-cancel             \
                --width     600         \
                --height    50          \
                --title     "$TITLE"    \
                --text      "$text0"    2> >($LOGCMD)
    else
        process_option_list_manual_installed
        process_option_list_snaps
        process_option_list_added_repos
    fi

    info '
De instellingen zijn vastgelegd in de map kz in Documenten.
In map kz het bestand Applijst met de eerder geïnstalleerde apps.
Dit bestand kan worden gebruikt voor het nalopen van de installatie.'
}

function process_option_list_manual_installed {
    local       footer=''
    local       header="1. Deze pakketten zijn handmatig geïnstalleerd via \
Software of
   met een opdracht zoals 'sudo apt-get --install <pakket|bestand>':"
    local -i    number_of_lines=0
    local       plural='geïnstalleerde pakketten'

    printf '%s\n' "$text1..."
    printf '%b\n' "$header\n$DASHES" > "$TEMP_LIST"

    apt list --manual-installed 2> >($LOGCMD) >> "$TEMP_LIST"

    number_of_lines=$(wc --lines < "$TEMP_LIST")
    number_of_lines=$((number_of_lines - 4))
    if [[ $number_of_lines -eq 1 ]]; then
        plural='geïnstalleerd pakket'
    fi
    footer="Dit overzicht bevat $number_of_lines handmatig $plural."
    printf '%b\n' "$DASHES\n$footer\n" >> "$TEMP_LIST"

    cat "$TEMP_LIST" > "$app_list"
}

function process_option_list_snaps {
    local       footer=''
    local       header="2. Deze snaps zijn geïnstalleerd met '[sudo] install \
<snap>' of met Software:"
    local -i    number_of_lines=0
    local       plural='snaps'

    printf '%s\n' "$text3..."
    printf '%b\n' "$header\n$DASHES" > "$TEMP_LIST"

    if ! snap list 2> /dev/null >> "$TEMP_LIST"; then
        TEXT='snap is niet geïnstalleerd op dit systeem'
        printf '%s\n' "$TEXT" >> "$TEMP_LIST"
    fi

    number_of_lines=$(wc --lines < "$TEMP_LIST")
    number_of_lines=$((number_of_lines - 3))
    if [[ $number_of_lines -eq 1 ]]; then
        plural='snap'
    fi
    footer="Dit overzicht bevat $number_of_lines $plural."
    printf '%b\n' "$DASHES\n$footer\n" >> "$TEMP_LIST"

    cat "$TEMP_LIST" >> "$app_list"
}

function process_option_list_added_repos {
    local       footer=''
    local       header="3. Deze pakketbronnen zijn toegevoegd met de \
installatie van een pakket of
   met de opdracht 'sudo add-apt-repository ppa:<ppa-gebruiker>/<ppa-naam>':"
    local -i    number_of_lines=0
    local       plural='pakketbronnen'
    local       search=''

    printf '%s\n' "$text2..."
    printf '%b\n' "$header\n$DASHES" > "$TEMP_LIST"

    search=/etc/apt/sources.list
    cd  $search.d || exit $ERROR
    if !    grep    --recursive             \
                    --no-filename           \
                    --regexp='^deb '        \
                    --recursive             \
                    /etc/apt/sources.list   \
                    /etc/apt/sources.list.d |
            grep    --invert-match          \
                    --regexp='ubuntu.com'   |
            sort    --unique                >> "$TEMP_LIST"; then
        true
    fi

    number_of_lines=$(wc --lines < "$TEMP_LIST")
    number_of_lines=$((number_of_lines - 3))
    if [[ $number_of_lines -eq 1 ]]; then
        plural='pakketbron'
    fi
    footer="Dit overzicht bevat $number_of_lines toegevoegde $plural."
    printf '%b\n' "$DASHES\n$footer" >> "$TEMP_LIST"

    cat "$TEMP_LIST" >> "$app_list"
}

function process_file {
    local       app_description=''
    local -i    cmd_seq_num=0
    local       first_description_line=true
    local       first_remove_instruction=true
    local       prev_recordtype=''
    local       record=''
    local       recordtype=''
    local       write_app_description_line=true

    if $EXECUTE_COMMANDS; then
        STATUS_BUSY="[${BLINK}${BOLD}WERK${NORMAL}]"
        printf '%b' "${CURSOR_INVISABLE}"
    fi
    $skip_line && printf '\n'; skip_line=true

    while read -r record; do
        recordtype=${record:0:2}
        case $recordtype in
            '')
                # Lege regel.
                continue
                ;;
            '#1')
                process_app_description "$record"
                ;;
            '#2')
                process_remove_instruction "$record"
                ;;
            '#'*)
                # Commentaarregel.
                continue
                ;;
            *)
                process_command "$record"
                ;;
        esac
        prev_recordtype=$recordtype
    done < "$CMDS_FILE"

    if $EXECUTE_COMMANDS; then
        printf '%b' "${CURSOR_VISABLE}"
    fi
}

function process_app_description {
    local record=${1:-record?}

    if $OPTION_REMOVE; then
        app_description="${record:3}"' verwijderen'
    elif $OPTION_SIMULATE; then
        app_description="${record:3}"' installeren simuleren'
    else
        app_description="${record:3}"' installeren'
    fi
    if ! $OPTION_SIMULATE && ! $EXECUTE_COMMANDS; then
        return $SUCCESS
    fi
    write_app_description_line=true
    ((++app_seq_num))
    cmd_seq_num=0
}

function process_remove_instruction {
    local       record=${1:-record?}
    local       filler=''
    local -i    len=0

    REMOVE_FOUND=true
    if ! $OPTION_REMOVE; then
        return $SUCCESS
    fi
    filler=${SPACES:0:8}
    if [[ $prev_recordtype = '#2' ]]; then
        printf '%s%s\n' "$filler" "${record:3}" >> "$TEXT_FILE"
    else
        ((++app_seq_num))
        if $first_remove_instruction; then
            first_remove_instruction=false
        else
            printf '\n' >> "$TEXT_FILE"
        fi
        len=${#app_description}
        # ?? wordt in term_script vervangen door aantal te te verwijderen apps.
        printf  "[%2d/??] %s\n%s%.${len}s\n%s%s\n"  \
                "$app_seq_num"  "$app_description"  \
                "$filler"       "$DASHES"           \
                "$filler"       "${record:3}"       >> "$TEXT_FILE"
    fi
}

function process_command {
    local       cmd=${1:-cmd?}
    local       app_description_line=''
    local -i    cmd_rc=0
    local -i    desc_maxlen=1000
    local       desc_printf=''
    local       status=''

    COMMANDS_FOUND=true
    ((++cmd_seq_num))

    if $OPTION_SIMULATE; then
        if $write_app_description_line; then
            if $first_description_line; then
                first_description_line=false
            else
                printf '\n' >> "$TEXT_FILE"
            fi
            printf  '[%3d/%-3d] %s\n'   \
                    "$app_seq_num"      \
                    "$app_tot_num"      \
                    "$app_description"  >> "$TEXT_FILE"
            write_app_description_line=false
        fi
        printf  '%9s [%2d] %s\n'            \
                " "                         \
                "$cmd_seq_num"              \
                "${BLUE}$record${NORMAL}"   >> "$TEXT_FILE"
    elif $EXECUTE_COMMANDS; then
        desc_printf=$app_description
        if $OPTION_GUI; then
            TEXT="#[$app_seq_num/$app_tot_num] $app_description\n\n$record"
            printf '%s\n' "$TEXT"
        else
            if [[ -t 1 ]]; then
                # Afbreken in Terminalvenster moet i.v.m. updaten status.
                #  <------------- tput cols ------------->
                # '[WERK] [  1/1  ] [ 1] Te lange descr...' <=== op 1 regel
                #  <-------- 22 -------->
                desc_maxlen=$(($(tput cols) - 22))
                if [[ ${#desc_printf} -gt $desc_maxlen ]]; then
                    desc_printf=${desc_printf:0:(($desc_maxlen - 3))}'...'
                fi
            fi
        fi
        printf  -v app_description_line                             \
                "[%3d/%-3d] [%2d] %-${desc_maxlen}.${desc_maxlen}s" \
                "$app_seq_num"                                      \
                "$app_tot_num"                                      \
                "$cmd_seq_num"                                      \
                "$desc_printf"
        execute_command "$record"
    fi
}

function execute_command {
    local       cmd=${1:-cmd?}
    local -i    cmd_rc=0
    local       status=''

    check_dpkg
    if ! $OPTION_GUI; then
        if [[ $cmd_seq_num -eq 1 ]]; then
            printf "$STATUS_BUSY %s${CARRIAGE_RETURN}" "$app_description_line"
        else
            printf  "$STATUS_BUSY ${SPACES:0:9}%s${CARRIAGE_RETURN}" \
                    "${app_description_line:9}"
        fi
    fi

    log "$app_description_line"
    log "${BLUE}$cmd${NORMAL}"
    ERROR_MSG_TO_LOG=true
    eval "$cmd" |& $LOGCMD || cmd_rc=$?
    ERROR_MSG_TO_LOG=false
    if [[ $cmd_rc -gt $MAXRC ]]; then
        MAXRC=$cmd_rc
    fi
    if [[ $cmd_rc -eq $SUCCESS ]]; then
        status="$STATUS_SUCCESS"
    else
        status="$STATUS_ERROR"
    fi
    log "$status rc=$cmd_rc, maxrc=$MAXRC"
    if ! $OPTION_GUI; then
        printf '%s\n' "$status"
    fi
}

function check_dpkg {
    local -i wait_for_aptd=5

    if ls /snap/core/*/var/cache/debconf/config.dat &> /dev/null; then
        while sudo  fuser                                               \
                    /var/{lib/{dpkg,apt/lists},cache/apt/archives}/lock \
                    /var/cache/debconf/config.dat                       \
                    /snap/core/*/var/cache/debconf/config.dat           \
                    &> /dev/null; do
            log 'Wacht tot andere pakketbeheerder klaar is...'
            sleep $wait_for_aptd
        done
    else
        while sudo  fuser                                               \
                    /var/{lib/{dpkg,apt/lists},cache/apt/archives}/lock \
                    /var/cache/debconf/config.dat                       \
                    &> /dev/null; do
            log 'Wacht tot andere pakketbeheerder klaar is...'
            sleep $wait_for_aptd
        done
    fi
}

function term_script {
    local -i app_num=0

    if $OPTION_SIMULATE; then
        less_options "$TITLE"
        less "$LESS_OPTIONS" "$TEXT_FILE"
    elif $OPTION_REMOVE && $REMOVE_FOUND; then
        # Vervang ?? door aantal te verwijderen apps.
        app_num=$(grep --regexp='\??] ' --count "$TEXT_FILE")
        sed -i "s|/??] |/$(printf %-2d "$app_num")] |g" "$TEXT_FILE"
        less_options "$TITLE"
        less "$LESS_OPTIONS" "$TEXT_FILE"
    elif $OPTION_REMOVE && ! $REMOVE_FOUND; then
        info 'Geen verwijder-instructies.'
    elif ! $COMMANDS_FOUND; then
        info 'Geen opdrachten.'
    fi

    if $EXECUTE_COMMANDS; then
        if [[ $MAXRC -ne $SUCCESS ]]; then
            warning "
Installatie is geëindigd met een waarschuwing.

Controleer de log in het Terminalvenster met:
    ${BLUE}$LOGCMD_CHECK${NORMAL}"
            exit $WARNING
        else
            info "
${GREEN}Installatie is voltooid.${NORMAL}"
            exit $SUCCESS
        fi
    fi
}

###############################################################################
# Main line                                                                   #
###############################################################################

function main {
    init_script "$@"
    check_input "$@"
    process_input
    term_script
}

main "$@"
